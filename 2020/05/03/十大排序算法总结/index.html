<!DOCTYPE html>
<html  lang="zh">
<head>
    <meta charset="utf-8" />

<meta name="generator" content="Hexo 4.2.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>十大排序算法总结 - chen33的个人博客</title>


    <meta name="description" content="主要内容  排序的基本概念 10种排序算法代码演示 排序算法总结">
<meta property="og:type" content="article">
<meta property="og:title" content="十大排序算法总结">
<meta property="og:url" content="http://coderchen33.life/2020/05/03/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="chen33的个人博客">
<meta property="og:description" content="主要内容  排序的基本概念 10种排序算法代码演示 排序算法总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://coderchen33.life/images/og_image.png">
<meta property="article:published_time" content="2020-05-03T00:46:09.000Z">
<meta property="article:modified_time" content="2020-05-09T01:44:30.754Z">
<meta property="article:author" content="coderchen33">
<meta property="article:tag" content="algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://coderchen33.life/images/og_image.png">







<link rel="icon" href="/images/favicon.jpeg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css">


    
    
<style>body>.footer,body>.navbar,body>.section{opacity:0}</style>

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">

    
    
    
    
<link rel="stylesheet" href="/css/back-to-top.css">

    
    
    
    
    
    
    
    <link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
    
    <script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    


<link rel="stylesheet" href="/css/style.css">
</head>
<!-- <body class="is-2-column"> -->
<body class="is-3-column"></body>
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.png" alt="十大排序算法总结" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">主页</a>
                
                <a class="navbar-item"
                href="/archives">归档</a>
                
                <a class="navbar-item"
                href="/categories">分类</a>
                
                <a class="navbar-item"
                href="/tags">标签</a>
                
                <a class="navbar-item"
                href="/tools">工具</a>
                
                <a class="navbar-item"
                href="/about">关于我</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    <a class="navbar-item" target="_blank" rel="noopener" title="View Github" href="https://github.com/coderchen33">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                <a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;">
                    <i class="fas fa-list-ul"></i>
                </a>
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main">
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-05-03T00:46:09.000Z">2020-05-03</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    21 分钟 读完 (大约 3075 个字)
                </span>
                
                
                <span class="level-item has-text-grey" id="busuanzi_container_page_pv">
                    <i class="far fa-eye"></i>
                    <span id="busuanzi_value_page_pv">0</span>次访问
                </span>
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                十大排序算法总结
            
        </h1>
        <div class="content">
            <p><strong>主要内容</strong></p>
<ol>
<li>排序的基本概念</li>
<li>10种排序算法代码演示</li>
<li>排序算法总结<a id="more"></a>

</li>
</ol>
<h2 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h2><h3 id="1-排序的一般定义"><a href="#1-排序的一般定义" class="headerlink" title="1.排序的一般定义"></a>1.排序的一般定义</h3><p>排序是计算机中经常进行的操作，目的在于将一组无序的数据元素调整为有序的数据元素。<br>序列：1，20，45，5，2，12<br>排序后：1，2，5，12，20，45</p>
<h3 id="2-排序的稳定性"><a href="#2-排序的稳定性" class="headerlink" title="2.排序的稳定性"></a>2.排序的稳定性</h3><p>如果序列中的两个元素R[i]、R[j]，关键字分别为K[i]、K[j]并且K[i]=K[j]，在排序之前R[i]排在R[j]前面，如果排序操作后，元素R[i]仍然排在R[j]前面，则排序方法是稳定的；否则排序是不稳定的。</p>
<p>通俗的讲，就是<strong>排序前有两个相等的数a和b，且a在b前面，排序后如果a依然在b前面，则这次排序为稳定排序</strong> 。</p>
<blockquote>
<p>例如对4,2,1,3(A),3(B),5进行从小到大排序，则</p>
<ul>
<li>稳定排序： 1,2,3(A),3(B),4,5　　　3(A),3(B)和排序前顺序相同。</li>
<li>不稳定排序: 1,2,3(B),3(A),4,5　　　3(A),3(B)和排序前顺序不同。</li>
</ul>
</blockquote>
<p>这里我们先提一下我们下面要讲的排序算法的稳定性如下:</p>
<blockquote>
<ul>
<li>稳定排序： 冒泡排序、插入排序、归并排序、 基数排序</li>
<li>不稳定排序：选择排序、快速排序、希尔排序、 堆排序</li>
</ul>
</blockquote>
<h3 id="3-内排序和外排序"><a href="#3-内排序和外排序" class="headerlink" title="3.内排序和外排序"></a>3.内排序和外排序</h3><p><strong>内排序</strong> ：待排序列完全存放在内存中所进行的排序过程，适合不太大的元素序列<br><strong>外排序</strong>：指的是大文件的排序，即待排序的记录存储在外存储器上，无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。</p>
<h3 id="4-排序算法的性能评价"><a href="#4-排序算法的性能评价" class="headerlink" title="4.排序算法的性能评价"></a>4.排序算法的性能评价</h3><p><strong>时间性能</strong>:主要性能差异体现在比较和交换的数量<br><strong>辅助存储空间</strong>:为完成排序操作需要的额外的存储空间。必要时可以空间换时间<br><strong>算法的实现复杂性</strong>： 过于复杂的排序算法影响可读性和可维护性</p>
<h3 id="5-排序的分类如下"><a href="#5-排序的分类如下" class="headerlink" title="5.排序的分类如下:"></a>5.排序的分类如下:</h3><p>排序模板方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">//比较</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i&lt;j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = num[i];</span><br><span class="line">        num[i] = num[j];</span><br><span class="line">        num[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span>[] num)</span></span>&#123;</span><br><span class="line">        System.out.println(Arrays.toString(num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1.选择排序"></a>1.选择排序</h2><p><strong>算法过程</strong>:从数组中选择最小元素，将它与数组的第一个元素交换位置。再从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(less(num[j],num[min])) min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(num,i,min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择排序算法分析:<br><strong>时间复杂度</strong>: 因为无论怎样，选择排序都会进行1+2+……+（n-1）次比较操作，<strong>时间复杂度为<code>O(n^2)</code></strong><br><strong>空间复杂度</strong>： <strong><code>O(1)</code>  原地排序</strong><br><strong>稳定性</strong>: <strong>不稳定排序</strong>。  比如<code>5(A),8,5(B),2,9</code>  最终排完序后为 <code>2,5(B),5(A),8,9</code></p>
<h2 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2.冒泡排序"></a>2.冒泡排序</h2><p><strong>算法过程</strong>:从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。</p>
<p>在一轮循环中，如果没有发生交换，那么说明数组已经是有序的,可以通过添加标志位来避免无用的比较操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="keyword">boolean</span> exchange;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        exchange = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(less(num[j+<span class="number">1</span>],num[j])) &#123;</span><br><span class="line">                swap(num,j,j+<span class="number">1</span>);</span><br><span class="line">                exchange = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!exchange) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序算法分析:<br><strong>时间复杂度</strong>:<strong>平均时间复杂度为<code>O(n^2)</code></strong> 　最好情况：数组正序，复杂度为<code>O(n)</code> 最坏情况：数组倒序，复杂度为<code>O(n^2)</code><br><strong>空间复杂度</strong>：<strong><code>O(1)</code>　原地排序</strong><br><strong>稳定性</strong>:<strong>稳定排序</strong> 　因为只有在后一位比自己大时才交换,相等时不进行交换。</p>
<h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h2><p><strong>算法思想</strong>:每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;<span class="number">0</span> &amp;&amp; less(num[j],num[j-<span class="number">1</span>]); j--) &#123;</span><br><span class="line">            swap(num,j,j-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        show(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>对于数组 {3, 5, 2, 4, 1}，它具有以下逆序：(3, 2), (3, 1), (5, 2), (5, 4), (5, 1), (2, 1), (4, 1)，插入排序每次只能交换相邻元素，令逆序数量减少1，因此<strong>插入排序需要交换的次数为<code>逆序</code>数量</strong>。</p>
<p><strong>插入排序的时间复杂度取决于数组的初始顺序</strong>，如果数组已经部分有序了，那么逆序较少，需要的交换次数也就较少，时间复杂度较低。</p>
<ul>
<li>平均情况下插入排序需要 ~N2/4 比较以及 ~N2/4 次交换；</li>
<li>最坏的情况下需要 ~N2/2 比较以及 ~N2/2 次交换，最坏的情况是数组是倒序的；</li>
<li>最好的情况下需要 N-1 次比较和 0 次交换，最好的情况就是数组已经有序了。</li>
</ul>
<p>插入排序算法分析:<br><strong>时间复杂度</strong>:<strong>取决于数组的初始顺序</strong> 通常认为<strong>平均时间复杂度为<code>O(n^2)</code></strong><br><strong>空间复杂度</strong>：<strong><code>O(1)</code>　原地排序</strong><br><strong>稳定性</strong>:<strong>稳定排序</strong> 　因为只有在后一位比自己大时才插入,相等时直接插在后面所以是稳定排序。</p>
<h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a>4.希尔排序</h2><p>对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少1。希尔排序的出现就是为了解决插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。</p>
<p><strong>算法思想</strong>:希尔排序也是一种插入排序，也称为<strong>缩小增量排序</strong>。主要思想是使用插入排序对增量h的序列进行排序。通过不断减小h，最后令 h=1，就可以使得整个数组是有序的。</p>
<div align="center"><img src="http://coderchen33.life/2020-05-03-十大排序算法总结-2020-05-04-20-40-42"></div><br>

<p>可以参考上图，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，<code>{n/2,(n/2)/2...1}</code>，称为<strong>增量序列</strong>。希尔排序的增量序列的选择与证明是个数学难题。通常比较常见的有两种:</p>
<ul>
<li>{n/2,(n/2)/2…1}</li>
<li>1/2(3^k-1) 　　{1,4,…3h+1}　　(通常比上面的效率高)</li>
</ul>
<p>实现时不用循环按组处理，我们可以从第h个元素开始，逐个跨组处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="comment">//这里直接使用第二个增量序列</span></span><br><span class="line">    <span class="comment">//找到初始增量</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(h&lt;n/<span class="number">3</span>) h = <span class="number">3</span>*h+<span class="number">1</span>;  <span class="comment">//1,4,13,40...</span></span><br><span class="line">    <span class="comment">//排序过程</span></span><br><span class="line">    <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//就是一个插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;=h &amp;&amp; less(num[j],num[j-h]); j-=h) &#123;</span><br><span class="line">                swap(num,j,j-h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//改变增量</span></span><br><span class="line">        h = h/<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：<strong>O(n1.3)~O(n2)之间</strong><br><strong>空间复杂度</strong>：<strong><code>O(1)</code>　原地排序</strong><br><strong>稳定性</strong>:<strong>不稳定排序</strong> 相同元素可能分到不同的组中，每一组又单独进行插入排序，所以有可能其稳定性就会被打乱。</p>
<p>其实对于希尔排序的时间复杂度一直没有一个统一的说法，主要在于希尔排序取决于增量序列的选择。只需要知道 <strong>希尔排序超越了我们之前所讲的三种简单算法的O(n^2)</strong> 即可。</p>
<h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5.归并排序"></a>5.归并排序</h2><p><strong>算法思想</strong>:将一个数组(递归地)分成两部分分别进行排序，最后将结果归并起来。使用了<strong>分治法</strong>的思想。</p>
<blockquote>
<p>图片来自于文章 <a href="https://www.cnblogs.com/chengxiao/p/6194356.html">https://www.cnblogs.com/chengxiao/p/6194356.html</a></p>
</blockquote>
<div align="center"><img src="http://coderchen33.life/2020-05-03-十大排序算法总结-2020-05-06-09-31-40"></div><br>

<p><strong>自顶向下归并排序(递归)</strong></p>
<p>从上往下，将大数组分为小数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] workspace;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] num)</span></span>&#123;</span><br><span class="line">    workspace = <span class="keyword">new</span> <span class="keyword">int</span>[num.length];</span><br><span class="line">    sort(num,<span class="number">0</span>,num.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi-lo)/<span class="number">2</span>;</span><br><span class="line">    sort(num,lo,mid);  <span class="comment">//左半边排序</span></span><br><span class="line">    sort(num,mid+<span class="number">1</span>,hi);  <span class="comment">//右半边排序</span></span><br><span class="line">    merge(num,lo,mid,hi);  <span class="comment">//归并结果</span></span><br><span class="line">    show(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">        workspace[k] = num[k];  <span class="comment">//先复制到临时数组中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;=hi ; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; mid) num[k] = workspace[j++];  <span class="comment">//左边数组完成，右边没有完成</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi) num[k] = workspace[i++]; <span class="comment">//右边数组完成，左边没有完成</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(less(workspace[i],workspace[j])) num[k] = workspace[i++];  <span class="comment">//左边小于右边，num数组中放左边的值</span></span><br><span class="line">        <span class="keyword">else</span> num[k] = workspace[j++];  <span class="comment">//右边小于左边，num数组中放右边的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>贴一下运行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">初始数组:[<span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>]  <span class="comment">//6,2排序为2,6</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>]  <span class="comment">//7,4排序为4,7</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>]  <span class="comment">//2,6,4,7排序为2, 4, 6, 7</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>]  <span class="comment">//8,1排序为1,8</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>]  <span class="comment">//5,3排序为3,5</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>]  <span class="comment">//1, 8, 3, 5排序为1, 3, 5, 8</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]  <span class="comment">//最后整体排序</span></span><br></pre></td></tr></table></figure>

<p><strong>自底向上递归排序(迭代)</strong><br>先归并小数组，然后成对归并得到的小数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//merge没变，只需要更改sort即可</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span> num[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz&lt;n; sz+=sz) &#123;  <span class="comment">//sz子数组的大小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; n - sz; lo += sz + sz) &#123;  <span class="comment">//lo子数组索引</span></span><br><span class="line">            merge(num, lo, lo + sz - <span class="number">1</span>, Math.min(lo + sz + sz - <span class="number">1</span>, n- <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        show(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>归并排序复杂度分析:<br><strong>时间复杂度</strong>：<strong>始终是O(nlogn)</strong> 与数据的顺序无关<br><strong>空间复杂度</strong>：<strong><code>O(n)</code></strong>，借助了临时数组workspace<br><strong>稳定性</strong>:<strong>稳定排序</strong>  上面我们首先判断左边是否小于右边，所以是稳定个排序</p>
<h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6.快速排序"></a>6.快速排序</h2><p><strong>算法思想</strong></p>
<ul>
<li>归并排序将数组分为两个子数组分别排序，并将有序的子数组归并使得整个数组排序；</li>
<li>快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。</li>
</ul>
<div align="center"><img src="http://coderchen33.life/2020-05-03-十大排序算法总结-2020-05-06-21-13-30"></div><br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(Integer[] num)</span></span>&#123;</span><br><span class="line">        shuffle(num);  <span class="comment">//消除数组对数据的依赖性</span></span><br><span class="line">        qSort(num,<span class="number">0</span>,num.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">qSort</span><span class="params">(Integer[] num, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= low) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> j = partion(num,lo,hi);</span><br><span class="line">        qSort(num,lo,j-<span class="number">1</span>);</span><br><span class="line">        qSort(num,j+<span class="number">1</span>,hi);</span><br><span class="line">        show(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切分方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partion</span><span class="params">(Integer[] num,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将数组切分为num[lo..pivotkey-1],num[pivotkey],num[pivotkey+1..hi]</span></span><br><span class="line">        <span class="keyword">int</span> i = lo;  <span class="comment">//从左往右扫描指针</span></span><br><span class="line">        <span class="keyword">int</span> j = hi + <span class="number">1</span>;  <span class="comment">//从右往左扫描指针</span></span><br><span class="line">        <span class="keyword">int</span> pivotkey = num[lo];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//从左往右扫描直到找到一个大于等于pivotkey的元素</span></span><br><span class="line">            <span class="keyword">while</span>(less(num[++i],pivotkey)) <span class="keyword">if</span>(i==hi) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//从右往左扫描直到找到一个小于等于pivotkey的元素</span></span><br><span class="line">            <span class="keyword">while</span>(less(pivotkey,num[--j])) <span class="keyword">if</span>(j==lo) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//当两个指针相遇时，跳出循环进行之后的交换操作</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//交换位置</span></span><br><span class="line">            swap(num,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行num[lo]和左子数组最右侧元素num[j]交换，返回j即可</span></span><br><span class="line">        swap(num,lo,j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打乱数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(Integer[] num)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(num);</span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        list.toArray(num);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>快速排序的复杂度分析<br><strong>时间复杂度</strong>：<strong>平均是O(nlogn)</strong> 最好情况下，递归树的深度为log2n + 1次，时间复杂度为O(nlog2n)。最坏情况下，序列为正序或逆序,递归树画出来就是一个斜树，因此要执行n-1次递归调用，总的时间复杂度为<strong>O(n^2)</strong></p>
<p><strong>空间复杂度</strong>：从上面的分析可以看到，最好情况递归树的深度为log2n，最坏情况为O(n)。所以<strong>平均情况下快速排序的空间复杂度为O(logn)</strong></p>
<p><strong>稳定性</strong>： <strong>不稳定排序</strong> 因为关键字的比较和交换是跳跃进行的。</p>
<h3 id="快速排序的改进"><a href="#快速排序的改进" class="headerlink" title="快速排序的改进"></a>快速排序的改进</h3><p><strong>1.切换到插入排序</strong><br>因为快速排序在小数组中也会递归调用自己，对于小数组，插入排序比快速排序的性能更好，因此在小数组中可以切换到插入排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只需要在qSort中将if(hi &lt;= lo) return;替换为</span></span><br><span class="line"><span class="keyword">if</span>(hi &lt;= lo + M)&#123;</span><br><span class="line">    insertionSort(num,lo,hi);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.三数取中法</strong></p>
<p>一般找到数组的中位数最好，但是寻找数组中位数代价较高。一般取3个关键字先进行排序，将排在中间的数作为基准。一般是取左端，右端和中间三个数。当然数据量大的时候也可以九数取中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原来在partion中直接取数组最左边第一个数做pivotkey   int pivotkey = num[lo];</span></span><br><span class="line"><span class="comment">//这里可以直接调用函数得到</span></span><br><span class="line"><span class="keyword">int</span> pivotkey = getPivotkey(num);</span><br><span class="line"></span><br><span class="line"><span class="comment">//找三个数的中间的数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getPivotkey</span><span class="params">(Integer[] num,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivotkey;</span><br><span class="line">    <span class="keyword">int</span> mid = (lo+hi)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(num[lo]&gt;num[hi]) swap(num,lo,hi);</span><br><span class="line">    <span class="keyword">if</span>(num[mid]&gt;num[hi]) swap(num,mid,hi);</span><br><span class="line">    <span class="keyword">if</span>(num[mid]&gt;num[lo]) swap(num,mid,lo);</span><br><span class="line">    pivotkey = num[lo];</span><br><span class="line">    <span class="keyword">return</span> pivotkey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.三向切分法</strong><br>对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。</p>
<p><strong>对于有大量重复元素的随机数组，三向切分法可以将排序时间从线性对数级别降低到线性级别</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 维护3个指针，lt, i , gt</span></span><br><span class="line"><span class="comment"> * num[lo..lt-1]都小于pivotkey  num[gt+1..hi]都大于pivotkey</span></span><br><span class="line"><span class="comment"> * num[lt..i-1]都等于pivotkey   num[i..gt]元素未确定</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 最终num[lo..lt-1]&lt;pivotkey = num[lt..gt] &lt; num[gt+1..hi]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quick3wayQsort</span><span class="params">(Integer[] num,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> lt = lo;</span><br><span class="line">    <span class="keyword">int</span> i = lo+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> gt = hi;</span><br><span class="line">    <span class="keyword">int</span> pivotkey = num[lo];</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= gt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(less(num[i], pivotkey)) swap(num,lt++,i++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(less(pivotkey,num[i])) swap(num,i,gt--);</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;  <span class="comment">//现在num[lo..lt-1]&lt;pivotkey = num[lt..gt] &lt; num[gt+1..hi]成立</span></span><br><span class="line">    qSort(num,lo,lt-<span class="number">1</span>);</span><br><span class="line">    qSort(num,gt+<span class="number">1</span>,hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7.堆排序"></a>7.堆排序</h2><p>堆排序的复杂度分析<br><strong>时间复杂度</strong>：<strong>平均是O(nlogn)</strong> 构建初始堆经复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)…1]逐步递减，近似为nlogn。<br><strong>空间复杂度</strong>：<strong>O(1)  就地排序</strong><br><strong>稳定性</strong>： <strong>不稳定排序</strong> 记录的比较与交换是跳跃式的</p>
<hr>
<h2 id="8-桶排序"><a href="#8-桶排序" class="headerlink" title="8.桶排序"></a>8.桶排序</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h2>
        </div>
        
        <div class="level is-size-7 is-uppercase">
            <div class="level-start">
                <div class="level-item">
                    <span class="is-size-6 has-text-grey has-mr-7">#</span>
                    <a class="has-link-grey -link" href="/tags/algorithm/" rel="tag">algorithm</a>
                </div>
            </div>
        </div>
        
        
        
        <div class="social-share"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css">
<script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script>
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3>
        <div class="buttons is-centered">
            
                
<a class="button is-info donate">
    <span class="icon is-small">
        <i class="fab fa-alipay"></i>
    </span>
    <span>支付宝</span>
    <div class="qrcode"><img src="/images/Alipay.jpg" alt="支付宝"></div>
</a>

                
                
<a class="button is-success donate">
    <span class="icon is-small">
        <i class="fab fa-weixin"></i>
    </span>
    <span>微信</span>
    <div class="qrcode"><img src="/images/WechatPay.jpg" alt="微信"></div>
</a>

                
        </div>
    </div>
</div>



<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/2020/05/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%80%BB%E7%BB%93/">
                <span class="level-item">数据结构的时间复杂度总结</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>


</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left is-sticky">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                    <figure class="image is-128x128 has-mb-6">
                        <img class="is-rounded" src="/images/avatar.png" alt="chen33">
                    </figure>
                    
                    <p class="is-size-4 is-block">
                        chen33
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        时光你别催 我还有梦要追
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>Xi&#39;an</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        文章
                    </p>
                    <a href="/archives">
                        <p class="title has-text-weight-normal">
                            45
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        分类
                    </p>
                    <a href="/categories">
                        <p class="title has-text-weight-normal">
                            8
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        标签
                    </p>
                    <a href="/tags">
                        <p class="title has-text-weight-normal">
                            12
                        </p>
                    </a>
                </div>
            </div>
        </nav>
        
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/coderchen33" target="_blank" rel="noopener">
                关注我</a>
        </div>
        
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="QQ" href="/images/QQ.jpg">
                
                <i class="fab fa-qq"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="Github" href="https://github.com/coderchen33">
                
                <i class="fab fa-github"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        

    <div class="card widget" id="toc">
        <div class="card-content">
            <div class="menu">
                <h3 class="menu-label">
                    目录
                </h3>
                <ul class="menu-list"><li>
        <a class="is-flex" href="#排序的基本概念">
        <span class="has-mr-6">1</span>
        <span>排序的基本概念</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#1-排序的一般定义">
        <span class="has-mr-6">1.1</span>
        <span>1.排序的一般定义</span>
        </a></li><li>
        <a class="is-flex" href="#2-排序的稳定性">
        <span class="has-mr-6">1.2</span>
        <span>2.排序的稳定性</span>
        </a></li><li>
        <a class="is-flex" href="#3-内排序和外排序">
        <span class="has-mr-6">1.3</span>
        <span>3.内排序和外排序</span>
        </a></li><li>
        <a class="is-flex" href="#4-排序算法的性能评价">
        <span class="has-mr-6">1.4</span>
        <span>4.排序算法的性能评价</span>
        </a></li><li>
        <a class="is-flex" href="#5-排序的分类如下">
        <span class="has-mr-6">1.5</span>
        <span>5.排序的分类如下:</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#1-选择排序">
        <span class="has-mr-6">2</span>
        <span>1.选择排序</span>
        </a></li><li>
        <a class="is-flex" href="#2-冒泡排序">
        <span class="has-mr-6">3</span>
        <span>2.冒泡排序</span>
        </a></li><li>
        <a class="is-flex" href="#3-插入排序">
        <span class="has-mr-6">4</span>
        <span>3.插入排序</span>
        </a></li><li>
        <a class="is-flex" href="#4-希尔排序">
        <span class="has-mr-6">5</span>
        <span>4.希尔排序</span>
        </a></li><li>
        <a class="is-flex" href="#5-归并排序">
        <span class="has-mr-6">6</span>
        <span>5.归并排序</span>
        </a></li><li>
        <a class="is-flex" href="#6-快速排序">
        <span class="has-mr-6">7</span>
        <span>6.快速排序</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#快速排序的改进">
        <span class="has-mr-6">7.1</span>
        <span>快速排序的改进</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#7-堆排序">
        <span class="has-mr-6">8</span>
        <span>7.堆排序</span>
        </a></li><li>
        <a class="is-flex" href="#8-桶排序">
        <span class="has-mr-6">9</span>
        <span>8.桶排序</span>
        </a></li><li>
        <a class="is-flex" href="#">
        <span class="has-mr-6">10</span>
        <span></span>
        </a></li><li>
        <a class="is-flex" href="#排序算法总结">
        <span class="has-mr-6">11</span>
        <span>排序算法总结</span>
        </a></li></ul>
            </div>
        </div>
    </div>

    
    
        <div class="column-right-shadow is-hidden-widescreen is-sticky">
        
        </div>
    
</div>

                
            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.png" alt="十大排序算法总结" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2020 coderchen33&nbsp;版权所有
                <br>
                Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a>
                <!-- 
                <br>
                <span id="busuanzi_container_site_uv">
                共<span id="busuanzi_value_site_uv">0</span>个访客
                </span>
                 -->
                <br>
                <span id="busuanzi_container_site_pv" class="theme-info">
                    本站总访问量<span id="busuanzi_value_site_pv">0</span>次 |
                </span>
                <span id="busuanzi_container_site_uv">
                    本站访客数<span id="busuanzi_value_site_uv">0</span>人
                </span>
                <br>
                <a class="has-link-black-ter-2 -link" href="http://beian.miit.gov.cn/" target="_blank">陕ICP备20002539号</a>
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>


<script>
var IcarusThemeSettings = {
    site: {
        url: 'http://coderchen33.life',
        external_link: {"enable":true,"exclude":[]}
    },
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>





<script src="/js/animation.js"></script>



<script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
<script src="/js/gallery.js" defer></script>



<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>


<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>














<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>