<!DOCTYPE html>
<html  lang="zh">
<head>
    <meta charset="utf-8" />

<meta name="generator" content="Hexo 4.2.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>十大排序算法总结 - chen33的个人博客</title>


    <meta name="description" content="主要内容  排序的基本概念 10种排序算法代码演示 排序算法总结 Java中的排序算法">
<meta property="og:type" content="article">
<meta property="og:title" content="十大排序算法总结">
<meta property="og:url" content="http://coderchen33.life/2020/05/03/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="chen33的个人博客">
<meta property="og:description" content="主要内容  排序的基本概念 10种排序算法代码演示 排序算法总结 Java中的排序算法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://coderchen33.life/images/og_image.png">
<meta property="article:published_time" content="2020-05-03T00:46:09.000Z">
<meta property="article:modified_time" content="2020-05-10T00:08:58.558Z">
<meta property="article:author" content="coderchen33">
<meta property="article:tag" content="algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://coderchen33.life/images/og_image.png">







<link rel="icon" href="/images/favicon.jpeg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css">


    
    
<style>body>.footer,body>.navbar,body>.section{opacity:0}</style>

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">

    
    
    
    
<link rel="stylesheet" href="/css/back-to-top.css">

    
    
    
    
    
    
    
    <link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
    
    <script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    


<link rel="stylesheet" href="/css/style.css">
</head>
<!-- <body class="is-2-column"> -->
<body class="is-3-column"></body>
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.png" alt="十大排序算法总结" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">主页</a>
                
                <a class="navbar-item"
                href="/archives">归档</a>
                
                <a class="navbar-item"
                href="/categories">分类</a>
                
                <a class="navbar-item"
                href="/tags">标签</a>
                
                <a class="navbar-item"
                href="/tools">工具</a>
                
                <a class="navbar-item"
                href="/about">关于我</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    <a class="navbar-item" target="_blank" rel="noopener" title="View Github" href="https://github.com/coderchen33">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                <a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;">
                    <i class="fas fa-list-ul"></i>
                </a>
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main">
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-05-03T00:46:09.000Z">2020-05-03</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    27 分钟 读完 (大约 4012 个字)
                </span>
                
                
                <span class="level-item has-text-grey" id="busuanzi_container_page_pv">
                    <i class="far fa-eye"></i>
                    <span id="busuanzi_value_page_pv">0</span>次访问
                </span>
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                十大排序算法总结
            
        </h1>
        <div class="content">
            <p><strong>主要内容</strong></p>
<ol>
<li>排序的基本概念</li>
<li>10种排序算法代码演示</li>
<li>排序算法总结</li>
<li>Java中的排序算法<a id="more"></a>

</li>
</ol>
<h2 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h2><h3 id="排序的一般定义"><a href="#排序的一般定义" class="headerlink" title="排序的一般定义"></a>排序的一般定义</h3><p>排序是计算机中经常进行的操作，目的在于将一组无序的数据元素调整为有序的数据元素。<br>序列：1，20，45，5，2，12<br>排序后：1，2，5，12，20，45</p>
<h3 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h3><p>如果序列中的两个元素R[i]、R[j]，关键字分别为K[i]、K[j]并且K[i]=K[j]，在排序之前R[i]排在R[j]前面，如果排序操作后，元素R[i]仍然排在R[j]前面，则排序方法是稳定的；否则排序是不稳定的。</p>
<p>通俗的讲，就是<strong>排序前有两个相等的数a和b，且a在b前面，排序后如果a依然在b前面，则这次排序为稳定排序</strong> 。</p>
<blockquote>
<p>例如对4,2,1,3(A),3(B),5进行从小到大排序，则</p>
<ul>
<li>稳定排序： 1,2,3(A),3(B),4,5　　　3(A),3(B)和排序前顺序相同。</li>
<li>不稳定排序: 1,2,3(B),3(A),4,5　　　3(A),3(B)和排序前顺序不同。</li>
</ul>
</blockquote>
<p>这里我们先提一下我们下面要讲的排序算法的稳定性如下:</p>
<blockquote>
<ul>
<li>稳定排序： 冒泡排序、插入排序、归并排序、 基数排序</li>
<li>不稳定排序：选择排序、快速排序、希尔排序、 堆排序</li>
</ul>
</blockquote>
<h3 id="内排序和外排序"><a href="#内排序和外排序" class="headerlink" title="内排序和外排序"></a>内排序和外排序</h3><p><strong>内排序</strong> ：待排序列完全存放在内存中所进行的排序过程，适合不太大的元素序列<br><strong>外排序</strong>：指的是大文件的排序，即待排序的记录存储在外存储器上，无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。</p>
<h3 id="排序算法的性能评价"><a href="#排序算法的性能评价" class="headerlink" title="排序算法的性能评价"></a>排序算法的性能评价</h3><p><strong>时间性能</strong>:主要性能差异体现在比较和交换的数量<br><strong>辅助存储空间</strong>:为完成排序操作需要的额外的存储空间。必要时可以空间换时间<br><strong>算法的实现复杂性</strong>： 过于复杂的排序算法影响可读性和可维护性</p>
<h3 id="排序的模板方法如下；"><a href="#排序的模板方法如下；" class="headerlink" title="排序的模板方法如下；"></a>排序的模板方法如下；</h3><p>排序模板方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">//比较</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i&lt;j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = num[i];</span><br><span class="line">        num[i] = num[j];</span><br><span class="line">        num[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span>[] num)</span></span>&#123;</span><br><span class="line">        System.out.println(Arrays.toString(num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>算法过程</strong>:从数组中选择最小元素，将它与数组的第一个元素交换位置。再从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(less(num[j],num[min])) min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(num,i,min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择排序算法分析:<br><strong>时间复杂度</strong>: 因为无论怎样，选择排序都会进行1+2+……+（n-1）次比较操作，<strong>时间复杂度为<code>O(n^2)</code></strong><br><strong>空间复杂度</strong>： <strong><code>O(1)</code>  原地排序</strong><br><strong>稳定性</strong>: <strong>不稳定排序</strong>。  比如<code>5(A),8,5(B),2,9</code>  最终排完序后为 <code>2,5(B),5(A),8,9</code></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><strong>算法过程</strong>:从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。</p>
<p>在一轮循环中，如果没有发生交换，那么说明数组已经是有序的,可以通过添加标志位来避免无用的比较操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="keyword">boolean</span> exchange;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        exchange = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(less(num[j+<span class="number">1</span>],num[j])) &#123;</span><br><span class="line">                swap(num,j,j+<span class="number">1</span>);</span><br><span class="line">                exchange = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!exchange) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序算法分析:<br><strong>时间复杂度</strong>:<strong>平均时间复杂度为<code>O(n^2)</code></strong> 　最好情况：数组正序，复杂度为<code>O(n)</code> 最坏情况：数组倒序，复杂度为<code>O(n^2)</code><br><strong>空间复杂度</strong>：<strong><code>O(1)</code>　原地排序</strong><br><strong>稳定性</strong>:<strong>稳定排序</strong> 　因为只有在后一位比自己大时才交换,相等时不进行交换。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>算法思想</strong>:每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;<span class="number">0</span> &amp;&amp; less(num[j],num[j-<span class="number">1</span>]); j--) &#123;</span><br><span class="line">            swap(num,j,j-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        show(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>对于数组 {3, 5, 2, 4, 1}，它具有以下逆序：(3, 2), (3, 1), (5, 2), (5, 4), (5, 1), (2, 1), (4, 1)，插入排序每次只能交换相邻元素，令逆序数量减少1，因此<strong>插入排序需要交换的次数为<code>逆序</code>数量</strong>。</p>
<p><strong>插入排序的时间复杂度取决于数组的初始顺序</strong>，如果数组已经部分有序了，那么逆序较少，需要的交换次数也就较少，时间复杂度较低。</p>
<ul>
<li>平均情况下插入排序需要 ~N2/4 比较以及 ~N2/4 次交换；</li>
<li>最坏的情况下需要 ~N2/2 比较以及 ~N2/2 次交换，最坏的情况是数组是倒序的；</li>
<li>最好的情况下需要 N-1 次比较和 0 次交换，最好的情况就是数组已经有序了。</li>
</ul>
<p>插入排序算法分析:<br><strong>时间复杂度</strong>:<strong>取决于数组的初始顺序</strong> 通常认为<strong>平均时间复杂度为<code>O(n^2)</code></strong><br><strong>空间复杂度</strong>：<strong><code>O(1)</code>　原地排序</strong><br><strong>稳定性</strong>:<strong>稳定排序</strong> 　因为只有在后一位比自己大时才插入,相等时直接插在后面所以是稳定排序。</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少1。希尔排序的出现就是为了解决插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。</p>
<p><strong>算法思想</strong>:希尔排序也是一种插入排序，也称为<strong>缩小增量排序</strong>。主要思想是使用插入排序对增量h的序列进行排序。通过不断减小h，最后令 h=1，就可以使得整个数组是有序的。</p>
<div align="center"><img src="http://coderchen33.life/2020-05-03-十大排序算法总结-2020-05-04-20-40-42"></div><br>

<p>可以参考上图，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，<code>{n/2,(n/2)/2...1}</code>，称为<strong>增量序列</strong>。希尔排序的增量序列的选择与证明是个数学难题。通常比较常见的有两种:</p>
<ul>
<li>{n/2,(n/2)/2…1}</li>
<li>1/2(3^k-1) 　　{1,4,…3h+1}　　(通常比上面的效率高)</li>
</ul>
<p>实现时不用循环按组处理，我们可以从第h个元素开始，逐个跨组处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="comment">//这里直接使用第二个增量序列</span></span><br><span class="line">    <span class="comment">//找到初始增量</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(h&lt;n/<span class="number">3</span>) h = <span class="number">3</span>*h+<span class="number">1</span>;  <span class="comment">//1,4,13,40...</span></span><br><span class="line">    <span class="comment">//排序过程</span></span><br><span class="line">    <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//就是一个插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;=h &amp;&amp; less(num[j],num[j-h]); j-=h) &#123;</span><br><span class="line">                swap(num,j,j-h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//改变增量</span></span><br><span class="line">        h = h/<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：<strong>O(n1.3)~O(n2)之间</strong><br><strong>空间复杂度</strong>：<strong><code>O(1)</code>　原地排序</strong><br><strong>稳定性</strong>:<strong>不稳定排序</strong> 相同元素可能分到不同的组中，每一组又单独进行插入排序，所以有可能其稳定性就会被打乱。</p>
<p>其实对于希尔排序的时间复杂度一直没有一个统一的说法，主要在于希尔排序取决于增量序列的选择。只需要知道 <strong>希尔排序超越了我们之前所讲的三种简单算法的O(n^2)</strong> 即可。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>算法思想</strong>:将一个数组(递归地)分成两部分分别进行排序，最后将结果归并起来。使用了<strong>分治法</strong>的思想。</p>
<blockquote>
<p>图片来自于文章 <a href="https://www.cnblogs.com/chengxiao/p/6194356.html">https://www.cnblogs.com/chengxiao/p/6194356.html</a></p>
</blockquote>
<div align="center"><img src="http://coderchen33.life/2020-05-03-十大排序算法总结-2020-05-06-09-31-40"></div><br>

<p><strong>自顶向下归并排序(递归)</strong></p>
<p>从上往下，将大数组分为小数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] workspace;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] num)</span></span>&#123;</span><br><span class="line">    workspace = <span class="keyword">new</span> <span class="keyword">int</span>[num.length];</span><br><span class="line">    sort(num,<span class="number">0</span>,num.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi-lo)/<span class="number">2</span>;</span><br><span class="line">    sort(num,lo,mid);  <span class="comment">//左半边排序</span></span><br><span class="line">    sort(num,mid+<span class="number">1</span>,hi);  <span class="comment">//右半边排序</span></span><br><span class="line">    merge(num,lo,mid,hi);  <span class="comment">//归并结果</span></span><br><span class="line">    show(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">        workspace[k] = num[k];  <span class="comment">//先复制到临时数组中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;=hi ; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; mid) num[k] = workspace[j++];  <span class="comment">//左边数组完成，右边没有完成</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi) num[k] = workspace[i++]; <span class="comment">//右边数组完成，左边没有完成</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(less(workspace[i],workspace[j])) num[k] = workspace[i++];  <span class="comment">//左边小于右边，num数组中放左边的值</span></span><br><span class="line">        <span class="keyword">else</span> num[k] = workspace[j++];  <span class="comment">//右边小于左边，num数组中放右边的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>贴一下运行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">初始数组:[<span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>]  <span class="comment">//6,2排序为2,6</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>]  <span class="comment">//7,4排序为4,7</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>]  <span class="comment">//2,6,4,7排序为2, 4, 6, 7</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>]  <span class="comment">//8,1排序为1,8</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>]  <span class="comment">//5,3排序为3,5</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>]  <span class="comment">//1, 8, 3, 5排序为1, 3, 5, 8</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]  <span class="comment">//最后整体排序</span></span><br></pre></td></tr></table></figure>

<p><strong>自底向上递归排序(迭代)</strong><br>先归并小数组，然后成对归并得到的小数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//merge没变，只需要更改sort即可</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span> num[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz&lt;n; sz+=sz) &#123;  <span class="comment">//sz子数组的大小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; n - sz; lo += sz + sz) &#123;  <span class="comment">//lo子数组索引</span></span><br><span class="line">            merge(num, lo, lo + sz - <span class="number">1</span>, Math.min(lo + sz + sz - <span class="number">1</span>, n- <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        show(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>归并排序复杂度分析:<br><strong>时间复杂度</strong>：<strong>始终是O(nlogn)</strong> 与数据的顺序无关<br><strong>空间复杂度</strong>：<strong><code>O(n)</code></strong>，借助了临时数组workspace<br><strong>稳定性</strong>:<strong>稳定排序</strong>  上面我们首先判断左边是否小于右边，所以是稳定个排序</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>算法思想</strong></p>
<ul>
<li>归并排序将数组分为两个子数组分别排序，并将有序的子数组归并使得整个数组排序；</li>
<li>快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。</li>
</ul>
<div align="center"><img src="http://coderchen33.life/2020-05-03-十大排序算法总结-2020-05-06-21-13-30"></div><br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(Integer[] num)</span></span>&#123;</span><br><span class="line">        shuffle(num);  <span class="comment">//消除数组对数据的依赖性</span></span><br><span class="line">        qSort(num,<span class="number">0</span>,num.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">qSort</span><span class="params">(Integer[] num, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= low) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> j = partion(num,lo,hi);</span><br><span class="line">        qSort(num,lo,j-<span class="number">1</span>);</span><br><span class="line">        qSort(num,j+<span class="number">1</span>,hi);</span><br><span class="line">        show(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切分方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partion</span><span class="params">(Integer[] num,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将数组切分为num[lo..pivotkey-1],num[pivotkey],num[pivotkey+1..hi]</span></span><br><span class="line">        <span class="keyword">int</span> i = lo;  <span class="comment">//从左往右扫描指针</span></span><br><span class="line">        <span class="keyword">int</span> j = hi + <span class="number">1</span>;  <span class="comment">//从右往左扫描指针</span></span><br><span class="line">        <span class="keyword">int</span> pivotkey = num[lo];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//从左往右扫描直到找到一个大于等于pivotkey的元素</span></span><br><span class="line">            <span class="keyword">while</span>(less(num[++i],pivotkey)) <span class="keyword">if</span>(i==hi) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//从右往左扫描直到找到一个小于等于pivotkey的元素</span></span><br><span class="line">            <span class="keyword">while</span>(less(pivotkey,num[--j])) <span class="keyword">if</span>(j==lo) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//当两个指针相遇时，跳出循环进行之后的交换操作</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//交换位置</span></span><br><span class="line">            swap(num,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行num[lo]和左子数组最右侧元素num[j]交换，返回j即可</span></span><br><span class="line">        swap(num,lo,j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打乱数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(Integer[] num)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(num);</span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        list.toArray(num);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>快速排序的复杂度分析<br><strong>时间复杂度</strong>：<strong>平均是O(nlogn)</strong> 最好情况下，递归树的深度为log2n + 1次，时间复杂度为O(nlog2n)。最坏情况下，序列为正序或逆序,递归树画出来就是一个斜树，因此要执行n-1次递归调用，总的时间复杂度为<strong>O(n^2)</strong></p>
<p><strong>空间复杂度</strong>：从上面的分析可以看到，最好情况递归树的深度为log2n，最坏情况为O(n)。所以<strong>平均情况下快速排序的空间复杂度为O(logn)</strong></p>
<p><strong>稳定性</strong>： <strong>不稳定排序</strong> 因为关键字的比较和交换是跳跃进行的。</p>
<h3 id="快速排序的改进"><a href="#快速排序的改进" class="headerlink" title="快速排序的改进"></a>快速排序的改进</h3><p><strong>1.切换到插入排序</strong><br>因为快速排序在小数组中也会递归调用自己，对于小数组，插入排序比快速排序的性能更好，因此在小数组中可以切换到插入排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只需要在qSort中将if(hi &lt;= lo) return;替换为</span></span><br><span class="line"><span class="keyword">if</span>(hi &lt;= lo + M)&#123;</span><br><span class="line">    insertionSort(num,lo,hi);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.三数取中法</strong></p>
<p>一般找到数组的中位数最好，但是寻找数组中位数代价较高。一般取3个关键字先进行排序，将排在中间的数作为基准。一般是取左端，右端和中间三个数。当然数据量大的时候也可以九数取中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原来在partion中直接取数组最左边第一个数做pivotkey   int pivotkey = num[lo];</span></span><br><span class="line"><span class="comment">//这里可以直接调用函数得到</span></span><br><span class="line"><span class="keyword">int</span> pivotkey = getPivotkey(num);</span><br><span class="line"></span><br><span class="line"><span class="comment">//找三个数的中间的数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getPivotkey</span><span class="params">(Integer[] num,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivotkey;</span><br><span class="line">    <span class="keyword">int</span> mid = (lo+hi)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(num[lo]&gt;num[hi]) swap(num,lo,hi);</span><br><span class="line">    <span class="keyword">if</span>(num[mid]&gt;num[hi]) swap(num,mid,hi);</span><br><span class="line">    <span class="keyword">if</span>(num[mid]&gt;num[lo]) swap(num,mid,lo);</span><br><span class="line">    pivotkey = num[lo];</span><br><span class="line">    <span class="keyword">return</span> pivotkey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.三向切分法</strong><br>对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。</p>
<p><strong>对于有大量重复元素的随机数组，三向切分法可以将排序时间从线性对数级别降低到线性级别</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 维护3个指针，lt, i , gt</span></span><br><span class="line"><span class="comment"> * num[lo..lt-1]都小于pivotkey  num[gt+1..hi]都大于pivotkey</span></span><br><span class="line"><span class="comment"> * num[lt..i-1]都等于pivotkey   num[i..gt]元素未确定</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 最终num[lo..lt-1]&lt;pivotkey = num[lt..gt] &lt; num[gt+1..hi]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quick3wayQsort</span><span class="params">(Integer[] num,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> lt = lo;</span><br><span class="line">    <span class="keyword">int</span> i = lo+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> gt = hi;</span><br><span class="line">    <span class="keyword">int</span> pivotkey = num[lo];</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= gt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(less(num[i], pivotkey)) swap(num,lt++,i++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(less(pivotkey,num[i])) swap(num,i,gt--);</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;  <span class="comment">//现在num[lo..lt-1]&lt;pivotkey = num[lt..gt] &lt; num[gt+1..hi]成立</span></span><br><span class="line">    qSort(num,lo,lt-<span class="number">1</span>);</span><br><span class="line">    qSort(num,gt+<span class="number">1</span>,hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>关于优先队列和堆的定义和基本性质参考<a href="http://www.coderchen33.life/2020/04/29/基本数据结构之数组、链表、栈、队列/">我的文章</a> </p>
<p><strong>算法思想</strong>：把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列，这就是堆排序。</p>
<p>主要包含两步:</p>
<ol>
<li>构建堆</li>
<li>交换堆顶元素与最后一个元素</li>
</ol>
<p>无序数组建立堆最直接的方法是从左到右遍历数组进行上浮操作。一个更高效的方法是从右至左进行下沉操作，如果一个节点的两个子节点都已经是有序的，那么进行下沉操作可以使得这个节点为根节点的堆有序。叶子节点不需要进行下沉操作，可以忽略叶子节点的元素，因此只需要遍历一半的元素即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = num.length;</span><br><span class="line">    <span class="comment">//构造堆</span></span><br><span class="line">    <span class="comment">//使用shiftDown方法将num[1]到num[N]排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = N/<span class="number">2</span>;k&gt;=<span class="number">1</span>;k--)&#123;</span><br><span class="line">        shiftDown(num,k,N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将num[1]和num[N]交换并修复堆</span></span><br><span class="line">    <span class="comment">//重复直到堆变空</span></span><br><span class="line">    <span class="keyword">while</span>(N&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        swap(num,<span class="number">1</span>,N--);</span><br><span class="line">        shiftDown(num,<span class="number">1</span>,N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> k, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">        <span class="comment">//和两个孩子节点中值大的交换</span></span><br><span class="line">        <span class="keyword">if</span> (j&lt;N &amp;&amp; less(num,j, j + <span class="number">1</span>))</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span> (!less(num,k, j))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(num,k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组num[0]放元素，如果要放元素，并且对数组进行排序，则需要将less和swap中的索引减1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num[i-<span class="number">1</span>]&lt;num[j-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = num[i-<span class="number">1</span>];</span><br><span class="line">    num[i-<span class="number">1</span>] = num[j-<span class="number">1</span>];</span><br><span class="line">    num[j-<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆排序的复杂度分析<br><strong>时间复杂度</strong>：<strong>平均是O(nlogn)</strong> 构建初始堆经复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)…1]逐步递减，近似为nlogn。<br><strong>空间复杂度</strong>：<strong>O(1)  就地排序</strong><br><strong>稳定性</strong>： <strong>不稳定排序</strong> 记录的比较与交换是跳跃式的</p>
<hr>
<p>下面的三种方法都是线性时间非比较类排序：</p>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p><strong>算法思想</strong>：核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.先找出最大和最小元素</span></span><br><span class="line">    <span class="keyword">int</span> min = num[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = num[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i]&lt;min) min = num[i];</span><br><span class="line">        <span class="keyword">if</span>(num[i]&gt;max) max = num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[max-min+<span class="number">1</span>];</span><br><span class="line">    Arrays.fill(bucket,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//元素对应放入bucket中并计数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        bucket[num[i]-min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(bucket[i] != <span class="number">0</span>)&#123;</span><br><span class="line">            num[index++] = i+min;</span><br><span class="line">            bucket[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"排序后"</span>+Arrays.toString(num));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计数排序复杂度分析<br><strong>时间复杂度</strong>：<strong>始终是O(n+k)</strong> 整个过程是对待排数组进行遍历。<br><strong>空间复杂度</strong>：<strong>O(num[max]-num[min])</strong> 从上面可以看到，计数排序需要一个num[max]-num[min]长度的数组做辅助来排序<br><strong>稳定性</strong>:<strong>稳定排序</strong> 由于计数排序都没有出现比较元素的操作。这个算法很明显是稳定的所以计数排序是稳定排序</p>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p><strong>算法思想</strong> 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> bucketSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = num[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = num[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i]&lt;min) min = num[i];</span><br><span class="line">        <span class="keyword">if</span>(num[i]&gt;max) max = num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bucketCount = (max-min)/bucketSize+<span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketnum= <span class="keyword">new</span> ArrayList&lt;&gt;(bucketCount);</span><br><span class="line">    <span class="keyword">int</span>[] newnum = <span class="keyword">new</span> <span class="keyword">int</span>[num.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">        bucketnum.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把数据放入桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;num.length ; i++) &#123;</span><br><span class="line">        bucketnum.get((num[i]-min)/bucketSize).add(num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">        <span class="comment">//对于每个桶中的数据可以使用其他排序方式排序</span></span><br><span class="line">        <span class="comment">//也可以使用桶排序进行递归调用，但是涉及到list和array之间的转换比较繁琐</span></span><br><span class="line">        <span class="comment">//所以最好是待排序数组是list时比较方便</span></span><br><span class="line">        Collections.sort(bucketnum.get(i));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketnum.get(i).size(); j++) &#123;</span><br><span class="line">            newnum[index++] = bucketnum.get(i).get(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>桶排序复杂度分析<br><strong>时间复杂度</strong>：<strong>平均是O(n+k)</strong>桶排序包括两个部分：<br>1.循环计算每个关键字的桶映射函数，这个时间复杂度是O(n)。2.利用先进的比较排序算法对每个桶内的所有数据进行排序。很显然，第2部分是桶排序性能好坏的决定因素。</p>
<p><strong>空间复杂度</strong>：<strong>O(n+k)</strong> 如果相对于同样的n，桶数量k越大，其效率越高，最好的时间复杂度达到O(n)。当然桶排序的空间复杂度为O(n+k)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。<br><strong>稳定性</strong>:<strong>稳定排序</strong> 对于桶排序，在对每个桶内数据进行排序时，由于排序算法使用的不同，可能会出现不稳定排序，但是使用桶排序递归排序时是稳定排序，所以一般认为桶排序是稳定排序</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p><strong>算法思想</strong>：按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.先找出最大位的位数</span></span><br><span class="line">    <span class="keyword">int</span> maxNum = num[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i]&gt;maxNum) maxNum = num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxDigit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(maxNum != <span class="number">0</span>)&#123;</span><br><span class="line">        maxNum /= <span class="number">10</span>;</span><br><span class="line">        maxDigit++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> div = <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        bucketList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++,mod *=<span class="number">10</span>,div *=<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = (num[j] % mod)/div;</span><br><span class="line">            bucketList.get(num).add(num[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketList.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketList.get(j).size(); k++) &#123;</span><br><span class="line">                num[index++] = bucketList.get(j).get(k);</span><br><span class="line">            &#125;</span><br><span class="line">            bucketList.get(j).clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基数排序复杂度分析<br><strong>时间复杂度</strong>：<strong>O(nk)</strong> 该算法所花的时间基本是在把元素分配到桶里和把元素从桶里串起来；把元素分配到桶里：循环 n 次；把元素从桶里串起来也是n次<br><strong>空间复杂度</strong>：<strong>O(n+k)</strong> 该算法的空间复杂度就是在分配元素时，使用的桶空间<br><strong>稳定性</strong>:<strong>稳定排序</strong></p>
<h2 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h2><div align="center"><img src="http://coderchen33.life/2020-05-03-十大排序算法总结-2020-05-09-23-58-43"></div><br>


<p>从上面的图中我们可以把非线性时间比较排序分为两类：</p>
<ul>
<li>简单算法：直接插入、直接选择、冒泡</li>
<li>改进算法：希尔排序、堆排序、快速排序、 归并排序</li>
</ul>
<p>从平均情况看，希尔排序是突破了O(n^2)。但是后三种改进算法要胜过希尔排序，并远胜过前三种简单算法。</p>
<p>从最好情况看，反而冒泡排序和直接插入排序效果最好，也就是说，<strong>如果待排序列总是基本有序，反而可以直接使用冒泡或者直接插入排序</strong>。</p>
<p>从最坏情况看，堆排序与归并排序又好于快速排序和其他简单排序，所以对于<strong>待排序列基本倒叙则可以考虑堆排序和归并排序</strong>。</p>
<p>从空间复杂度上来所，归并排序和快速排序都有相应的空间要求，反而堆排序确是O(1)，所以<strong>对于只有少量内存进行排序时可以考虑使用堆排序。并且对于海量数据的排序可以通过建立小顶堆或者大顶堆的方式进行排序</strong>。</p>
<p>另外对于线性时间非比较类的3种排序方法：<br>计数排序更适用于在已知序列中的元素0-k之间，且要求排序的复杂度在线性效率上的情况。<br>桶排序可应用于数据量分布比较均匀，或比较侧重区间数量时使用。<br>基数排序最适用于基数很大但关键字较小的序列</p>
<h2 id="Java中的排序算法"><a href="#Java中的排序算法" class="headerlink" title="Java中的排序算法"></a>Java中的排序算法</h2><p><strong>Java中主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序</strong>。</p>

        </div>
        
        <div class="level is-size-7 is-uppercase">
            <div class="level-start">
                <div class="level-item">
                    <span class="is-size-6 has-text-grey has-mr-7">#</span>
                    <a class="has-link-grey -link" href="/tags/algorithm/" rel="tag">algorithm</a>
                </div>
            </div>
        </div>
        
        
        
        <div class="social-share"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css">
<script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script>
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3>
        <div class="buttons is-centered">
            
                
<a class="button is-info donate">
    <span class="icon is-small">
        <i class="fab fa-alipay"></i>
    </span>
    <span>支付宝</span>
    <div class="qrcode"><img src="/images/Alipay.jpg" alt="支付宝"></div>
</a>

                
                
<a class="button is-success donate">
    <span class="icon is-small">
        <i class="fab fa-weixin"></i>
    </span>
    <span>微信</span>
    <div class="qrcode"><img src="/images/WechatPay.jpg" alt="微信"></div>
</a>

                
        </div>
    </div>
</div>



<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        <div class="level-start">
            <a class="level level-item has-link-grey  article-nav-prev" href="/2020/05/10/leetcode%E6%80%BB%E7%BB%93/">
                <i class="level-item fas fa-chevron-left"></i>
                <span class="level-item">leetcode总结</span>
            </a>
        </div>
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/2020/05/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%80%BB%E7%BB%93/">
                <span class="level-item">数据结构的时间复杂度总结</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>


</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left is-sticky">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                    <figure class="image is-128x128 has-mb-6">
                        <img class="is-rounded" src="/images/avatar.png" alt="chen33">
                    </figure>
                    
                    <p class="is-size-4 is-block">
                        chen33
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        时光你别催 我还有梦要追
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>Xi&#39;an</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        文章
                    </p>
                    <a href="/archives">
                        <p class="title has-text-weight-normal">
                            50
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        分类
                    </p>
                    <a href="/categories">
                        <p class="title has-text-weight-normal">
                            8
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        标签
                    </p>
                    <a href="/tags">
                        <p class="title has-text-weight-normal">
                            13
                        </p>
                    </a>
                </div>
            </div>
        </nav>
        
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/coderchen33" target="_blank" rel="noopener">
                关注我</a>
        </div>
        
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="QQ" href="/images/QQ.jpg">
                
                <i class="fab fa-qq"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="Github" href="https://github.com/coderchen33">
                
                <i class="fab fa-github"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        

    <div class="card widget" id="toc">
        <div class="card-content">
            <div class="menu">
                <h3 class="menu-label">
                    目录
                </h3>
                <ul class="menu-list"><li>
        <a class="is-flex" href="#排序的基本概念">
        <span class="has-mr-6">1</span>
        <span>排序的基本概念</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#排序的一般定义">
        <span class="has-mr-6">1.1</span>
        <span>排序的一般定义</span>
        </a></li><li>
        <a class="is-flex" href="#排序的稳定性">
        <span class="has-mr-6">1.2</span>
        <span>排序的稳定性</span>
        </a></li><li>
        <a class="is-flex" href="#内排序和外排序">
        <span class="has-mr-6">1.3</span>
        <span>内排序和外排序</span>
        </a></li><li>
        <a class="is-flex" href="#排序算法的性能评价">
        <span class="has-mr-6">1.4</span>
        <span>排序算法的性能评价</span>
        </a></li><li>
        <a class="is-flex" href="#排序的模板方法如下；">
        <span class="has-mr-6">1.5</span>
        <span>排序的模板方法如下；</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#选择排序">
        <span class="has-mr-6">2</span>
        <span>选择排序</span>
        </a></li><li>
        <a class="is-flex" href="#冒泡排序">
        <span class="has-mr-6">3</span>
        <span>冒泡排序</span>
        </a></li><li>
        <a class="is-flex" href="#插入排序">
        <span class="has-mr-6">4</span>
        <span>插入排序</span>
        </a></li><li>
        <a class="is-flex" href="#希尔排序">
        <span class="has-mr-6">5</span>
        <span>希尔排序</span>
        </a></li><li>
        <a class="is-flex" href="#归并排序">
        <span class="has-mr-6">6</span>
        <span>归并排序</span>
        </a></li><li>
        <a class="is-flex" href="#快速排序">
        <span class="has-mr-6">7</span>
        <span>快速排序</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#快速排序的改进">
        <span class="has-mr-6">7.1</span>
        <span>快速排序的改进</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#堆排序">
        <span class="has-mr-6">8</span>
        <span>堆排序</span>
        </a></li><li>
        <a class="is-flex" href="#计数排序">
        <span class="has-mr-6">9</span>
        <span>计数排序</span>
        </a></li><li>
        <a class="is-flex" href="#桶排序">
        <span class="has-mr-6">10</span>
        <span>桶排序</span>
        </a></li><li>
        <a class="is-flex" href="#基数排序">
        <span class="has-mr-6">11</span>
        <span>基数排序</span>
        </a></li><li>
        <a class="is-flex" href="#排序算法总结">
        <span class="has-mr-6">12</span>
        <span>排序算法总结</span>
        </a></li><li>
        <a class="is-flex" href="#Java中的排序算法">
        <span class="has-mr-6">13</span>
        <span>Java中的排序算法</span>
        </a></li></ul>
            </div>
        </div>
    </div>

    
    
        <div class="column-right-shadow is-hidden-widescreen is-sticky">
        
        </div>
    
</div>

                
            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.png" alt="十大排序算法总结" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2020 coderchen33&nbsp;版权所有
                <br>
                Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a>
                <!-- 
                <br>
                <span id="busuanzi_container_site_uv">
                共<span id="busuanzi_value_site_uv">0</span>个访客
                </span>
                 -->
                <br>
                <span id="busuanzi_container_site_pv" class="theme-info">
                    本站总访问量<span id="busuanzi_value_site_pv">0</span>次 |
                </span>
                <span id="busuanzi_container_site_uv">
                    本站访客数<span id="busuanzi_value_site_uv">0</span>人
                </span>
                <br>
                <a class="has-link-black-ter-2 -link" href="http://beian.miit.gov.cn/" target="_blank">陕ICP备20002539号</a>
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>


<script>
var IcarusThemeSettings = {
    site: {
        url: 'http://coderchen33.life',
        external_link: {"enable":true,"exclude":[]}
    },
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>





<script src="/js/animation.js"></script>



<script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
<script src="/js/gallery.js" defer></script>



<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>


<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>














<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>