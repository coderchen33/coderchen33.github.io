{"pages":[],"posts":[{"title":"计算机网络开篇","text":"计算机网络 搞起来 哇咔咔 互联网、因特网与万维网 互联网的组成 计算机网络类别 计算机网络的性能 计算机网络体系结构 互联网、因特网与万维网 互联网：网络把主机连接起来，而互联网是通过某种协议将多种不同的网络连接起来， 因此互联网是网络的网络。 国际标准的互联网写法是internet，字母i小写！ 因特网：采用TCP/IP协议族作为通信的规则的互联网。国际标准的因特网写法是Internet，字母I大写！ TCP/IP协议由很多协议组成，不同类型的协议又被放在不同的层，其中，位于应用层的协议就有很多，比如FTP、SMTP、HTTP。所以，因特网提供的服务一般包括有：www（万维网）服务、电子邮件服务（outlook）、远程登录（QQ）服务、文件传输（FTP）服务、网络电话等等 万维网(www)：只要应用层使用的是HTTP协议，就称为万维网。万维网又称环球网，是一种建立在Internet上的全球性的、交互的、动态、多平台、分布式、图形信息系统。它只是建立在Internet上的一种网络服务。 之所以在浏览器里输入百度网址时，能看见百度网提供的网页，就是因为你的个人浏览器和百度网的服务器之间使用的是HTTP协议在交流。 三者关系：互联网包含因特网，因特网包含万维网 目前，围绕互联网发展的业务主要有两类，分别是ISP（因特网服务提供商）与ICP（因特网网内容提供商） ISP(Internet Service Provider):指向广大用户综合提供互联网接入业务、信息业务和增值业务的电信运营商（比如中国电信、移动、联通提供的宽度服务）ISP拥有从因特网管理机构申请到的多个IP地址，同时拥有通信线路以及路由器等连网设备。中国的电信、网通等都是ISP，我们通常所说的上网就是指通过某个ISP接入到因特网，IP地址的管理机构不会把一个单个的IP地址分配给单个用户，而是把一批IP地址有偿地分配给经审查合格的ISP。现在的因特网是由全世界无数个大大小小的ISP所共同拥有的。 ICP(Internet Content Provider):向广大用户综合提供互联网信息和增值业务的企业（比如：新浪、搜狐、腾讯）。其实，我们说的ICP域名备案就是指互联网内容提供商向工信部提交经营审核。 互联网的组成因特网的拓扑结构虽然非常复杂，并且在地理上覆盖全球，单从工作方式上看，可以划分为以下两大块： 网络边缘：由所连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信和资源共享。主机也称为端系统 网络核心：由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的 在互联网边缘的端系统之间的通信方式通常可划分为两类： 客户服务器方式（Client/Server, C/S方式）：客户和服务器都是指通信中所涉及到的两个应用进程。最主要的特征是：客户是服务请求方，服务器是服务提供方C/S方式是因特网上最常用的传统方式，我们在网上发送电子邮件或在网站上查找资料时，都是客户服务器方式。 对等方式（Peer-to-Peer, P2P方式）：两个主机在通信时并不区分哪一个是服务请求者还是服务提供者，这要两个主机都运行了对等连接软件，他们就可以进行平等的、对等连接通信。这时，双方都可以下载对方已经存储在硬盘中的共享文档，因此这种工作方式也称为P2P文件共享。 还有一种被称为浏览器服务器的方式（B/S, Browser/Server方式），可以看作是客户服务器方式的特例。只不过客户端是浏览器而已。 互联网核心部分 电路交换 ：电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。 分组交换 ：分组交换采用存储转发技术。每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。 计算机网络类别按照网络的作用范围进行分类 广域网WAN:通过长距离(例如跨越不同国家)运送主机发送数据。 作用范围通常为几十到几千公里 城域网MAN: 一般是一个城市。 作用距离为5~50km 局域网LAN: 用计算机或工作站通过高速通信线路相连。作用距离为1km左右。学校或企业大都拥有多个互连的局域网称为校园网或企业网。 个人局域网PAN:把属于个人的电子设备用无线技术连接起来的网络，也常称为无线个人局域网(WPAN)。 作用距离10m左右。 按照网络的使用者进行分类 公用网： 指电信公司出资建造的大型网络。需要向电信公司交纳一定的费用 专用网： 指某个部门因为特殊业务工作需要而建造的网络。不向本单位以外的人提供服务。如军队、铁路、银行、电力系统等。 用来把用户接入到互联网的网络 接入网AN： 搭建起用户与互联网连接的”桥梁”。 计算机网络的性能 比特率：连接在计算机网络上的主机在数字信道上传送数据的速率。比特率速率的单位是b/s（比特每秒），有时候也写为bps，即bit persecond 带宽：表示在单位时间内从网络的某一点到另一点所能通过的最高数据率,单位是bit/s。 吞吐量：在单位时间内通过某个网络的实际数据量。是表示实际网络传输是的速率。 受网络带宽或网络的额定速率的限制。 时延：数据从网络一端传送到另一端所需要的时间。(1) 发送时延： 主机或路由器发送数据帧所需要的时间(2) 排队时延： 分组经过路由器后，要先在输入队列中排队等待处理(3) 处理时延： 主机或路由器收到分组时需要花费一定时间进行处理，如分析首部、提取数据部分、差错检测等。(4) 传播时延： 电磁波在信道中传播一定距离花费的时间。约为光速。 总时延 = 发送时延 + 排队时延 + 处理时 + 延传播时延 另外，在描述数据量大小时，往往使用字节（byte）作为度量单位。一个字节（记为大写的B）代表8个bit即1byte = 8bit在实际上网应用中，下载软件时常常看到诸如下载速度显示为176KB/s，103KB/s等宽带速率大小字样，因为ISP提供的线路带宽使用的单位是比特（bit），而一般下载软件显示的是字节（Byte）（1Byte=8bit），所以要通过换算，才能得实际值。我们以1M宽带为例，按照换算公式换算一下：1Mb/s=1024*1024b/s=1024K b/s=1024/8KB/s=128KB/s 计算机网络体系结构 OSI模型是国际标准组织提出过一个标准框架，只要遵循OSI标准，一个系统就可以和世界上任何地方的、也遵循统一标准的其他任何系统进行通信。但它既复杂又不实用。TCP/IP是一个四层的体系结构，包含应用层、传输层、网际层和网际接口层。不过从实质上讲，TCP/IP只有最上面的三层，网际接口层并没有什么具体内容。因此学习计算机网络的原理时往往采取折中的办法，即总和OSI和TCP/IP的优点，采用一种五层协议的体系结构。 下面看一下每层的具体作用： 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。传输层包括两种协议： 传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。 TCP 主要提供完整性服务，UDP 主要提供及时性服务。 网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。 数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 OSI中的剩余两层： 表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。 会话层 ：建立及管理会话。五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。 数据传输过程： 在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。","link":"/2020/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BC%80%E7%AF%87/"},{"title":"网络层(一)","text":"主要内容 虚拟互联网络的概念 IP地址和物理地址的关系 传统的分类的IP地址（子网掩码）和无分类域间路由选择CIDR 网络层服务及虚拟互联网的概念因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。 网络层向上只提供简单的、无连接的、尽最大努力交互(不可靠)的数据报服务。 无连接：IP并不需要事先建立连接或者维护任何关于后续数据报的状态信息。每个数据报的处理相互独立，并且可以不按发送顺序接收。 不可靠：它不能保证IP数据报能成功地到达目的地。IP仅提供最好的传输服务 所传送的分组可能出错、丢失、重复和失序，当然也不保证分组交付的时限。 使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络称为虚拟互联网络，由于使用的是IP协议也称为IP网。 与IP协议配套使用的还有三个协议： 地址解析协议 ARP (Address Resolution Protocol) 网际控制报文协议 ICMP (Internet Control Message Protocol) 网际组管理协议 IGMP (Internet Group Management Protocol) 逆地址解析协议(RARP) (DHCP协议(应用层协议)已经包含了RARP协议，所以RARP协议现在已经不使用了) IP地址和物理地址物理地址是数据链路层和物理层使用的地址，而IP地址（32位）是网络层和以上各层使用的地址，是一种逻辑地址。 下图为3个局域网用2个路由器R1和R2连接起来，现在主机H1要和主机H2进行通信。 通信路径为 H1-&gt;经过R1转发-&gt;经过R2转发-&gt;H2 其中路由器R1和R2同时连接在两个局域网上，因此有两个硬件地址 实际在不同层次中的不同区间的源地址和目的地址 我们可以知道： 在IP层抽象的互联网上只能看到IP数据报 路由器只根据目的IP地址进行路由选择 在局域网链路层只能看见MAC地址。 (从表中可以看到在从H1到H2通信过程中MAC帧首部的源地址和目的地址发生变化，在上面的IP层看不见这种变化) IP层抽象的互联网屏蔽了下层复杂细节，只要我们在网络层上讨论问题，就能够使用统一的、抽象的IP地址研究主机和主机或路由器之间的通信。 ARP协议网络层使用的是IP地址，最终在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。这就需要解决一个问题，如何根据一个机器的IP地址找出其对应的物理地址 地址解析协议ARP就是根据IP地址找出其对应的物理地址。 ARP工作过程： 当主机A要向本局域网上的某台主机B发送IP数据报，就先在其ARP高速缓存中查看有无主机B的IP地址。 如果ARP高速缓存中有该IP地址到MAC地址的映射，就在ARP高速缓存中查出其对应的硬件地址，再把硬件地址写入MAC帧中，然后通过局域网把该MAC地址发往此硬件地址。 如果没有，此时主机A就自动运行ARP。首先通过广播的方式发ARP请求分组，主机B收到该请求后会发送ARP响应分组给主机A告知其MAC地址。 主机A收到主机B的ARP响应分组后，向其高速缓存中写入主机B的IP地址到 MAC 地址的映射。 ARP协议抓包分析 ARP协议注意: ARP协议只在局域网中工作,如果要找的主机和源主机不在同一个局域网上(如上面的H1和H2)，H1就无法解析出另一个局域网H2主机。而是把路由器R1的IP地址解析为硬件地址HA3,以便能把IP数据报传送到路由器R1。 之后再由R1进行分组转发，直至最终交付给主机H2。 每个主机都有一个ARP高速缓存，里面有本局域网上的各主机和路由器的IP地址到MAC地址的映射表，并且这个映射表还可以动态更新。 IP地址划分IP地址就是给互联网上的每一台主机(或路由器)的每一个接口分配一个在全世界范围内唯一的32位的标识符。对IP地址的编址方式经历了三个历史阶段： 分类的IP地址 （最基本编址方法） 子网的划分 （对最基本编址方法的改进） 构成超网 （无分类编址，1993年提出后很快得到推广应用） 分类的IP地址由两部分组成，网络号和主机号。IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;} 这些32位的地址通常写成四个十进制的数，其中每个整数对应一个字节。这种表示方法称作“点分十进制表示法（Dotted decimal notation）”区分各类地址的最简单方法是看它的第一个十进制整数，如下图所示。 常用IP 子网的划分由三部分组成，网络号、子网号和主机号。IP地址 ::= {&lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;} 为什么需要划分子网呢，因为上面的两级IP地址虽然方便，但却有很多缺点： IP地址空间的利用率有时很低 给每一个物理网络分配一个网络号会使路由表变得太大而使网络性能变坏 两级IP地址不够灵活 所以为了解决上面的问题，所以在分类IP地址中增加了一个子网字段，使得两级IP地址变为三级IP地址。这种方法叫做划分子网 划分子网的注意: 划分子网纯属一个单位内部的事情。单位对外仍然表现为一个网络。 划分子网的方法是从主机号借用若干个位作为子网号subnet-id，而主机号host-id也就相应减少了若干个位。 凡是从其他网络发送给本单位某个主机的IP数据报，仍然是根据 IP 数据报的目的网络号 net-id，先找到连接在本单位网络上的路由器。然后此路由器在收到 IP 数据报后，再按目的网络号 net-id 和子网号 subnet-id 找到目的子网(需要借助于子网掩码)。最后就将 IP 数据报直接交付目的主机。 无分类编址CIDR（构造超网）由网络前缀号和主机号组成。IP地址::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;} 无分类编址CIDR消除了传统 A类、B类和C类地址以及划分子网的概念，并且网络前缀的长度可以根据需要变化。 CIDR的记法上采用在IP地址后面加上网络前缀长度的方法，例如 128.14.35.7/20表示前20位为网络前缀。 CIDR的地址掩码可以继续称为子网掩码，子网掩码1的长度为网络前缀的长度。 一个组织通常被分配成一块连续的地址，即具有相同前缀的一段地址，这种情况下，该组织内部的设备的IP地址将共享共同的前缀。剩余的32-x比特用于区分该组织内部设备。 一个 CIDR地址块中有很多地址，一个CIDR表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为构成超网。 子网掩码上面使用子网的IP地址和无分类编址CIDR都提到了子网掩码，什么是子网掩码呢？它的作用是什么呢？我们举个例子就可以理解了 下图表示某单位拥有一个B类IP地址，网络地址是145.13.0.0（网络号是145.13） 现把上图中的网络划分为三个子网，这里假定子网号占用8位，因此主机号只剩8位。所划分的子网分别是：145.13.3.0 145.13.7.0、145.13.21.0 划分子网后，整个网络对外仍表现为一个网络，其网络地址仍为145.13.0.0，但是路由器R1在收到外来的数据报后，再根据数据报的目的地址把它转发到相应的子网。 假定有一个数据报的目的地址是145.13.3.10已经到达路由器R1，那么这个路由器如何把它转发到子网145.13.3.0呢？这就需要借助子网掩码（subnetmask）来实现了。 路由器会把子网掩码和收到的数据报地址的目的IP地址145.13.3.10进行按位“与”操作，得出所要找的子网的网络地址 可以看到，子网掩码与IP地址进行“与”操作之后，就将主机号“过滤”掉了，只剩下了网络号与子网号。 实际上，因特网的标准规定：所有网络必须使用子网掩码。即便一个网络没有划分子网，也要使用默认子网掩码。默认子网掩码中1的位置和IP地址中的网络号字段正好相对应，因此，两者进行“与”操作后，就能得出该IP地址的网络地址。 A类、B类、C类地址的默认子网掩码是固定的： 例，已知 IP 地址是141.14.72.24（注意是IP数据报中的目的地址），子网掩码是 255.255.192.0。试求子网网络地址。","link":"/2020/03/07/%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"title":"物理层","text":"主要内容 物理层的任务 信道复用技术 宽带接入技术 物理层任务主要任务：确定与传输媒体的接口的一些特性。 机械特性 ：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等。 电气特性：指明在接口电缆的各条线上出现的电压的范围。4V— 6V表示二进制“0”,用-4V—-6V表示二进制“1” 功能特性：指明某条线上出现的某一电平的电压表示何种意义。 过程特性 ：指明对于不同功能的各种可能事件的出现顺序。 信道复用技术 频分复用：所有主机在相同的时间占用不同的频率带宽资源 时分复用：所有主机在不同的时间占用相同的频率带宽资源 统计时分复用：是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送 宽带接入技术 ADSL非对称数字用户线ASDL是用数字技术对模拟电话用户线进行改造。 ADSL把0~4kHZ的低频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。 由于我们在上网时主要是从互联网上下载各种文档，而向互联网发送的信息量一般都不打。因此ADSL的下行(从ISP到用户)带宽都远大于上行(从用户到ISP)带宽，因此成为非对称的。 ADSL 的特点： 上行和下行带宽做成不对称的。 ADSL 在用户线（铜线）的两端各安装一个 ADSL 调制解调器。 我国目前采用的方案是离散多音调 DMT，DMT 调制技术采用频分复用的方法 ADSL 采用自适应调制技术使用户线能够传送尽可能高的数据率 光纤同轴混合网（HFC网）在有线电视网的基础上开发的一种居民宽带接入网。 用户接口盒 UIB (User Interface Box) 要提供三种连接，即： 使用同轴电缆连接到机顶盒 (set-top box)，然后再连接到用户的电视机。 使用双绞线连接到用户的电话机。 使用电缆调制解调器连接到用户的计算机。 FTTx FTTx 表示 Fiber To The…（光纤到…），例如： 光纤到户 FTTH (Fiber To The Home)：光纤一直铺设到用户家庭，可能是居民接入网最后的解决方法。 光纤到大楼 FTTB (Fiber To The Building)：光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。 光纤到路边 FTTC (Fiber To The Curb)：光纤铺到路边，从路边到各用户可使用星形结构双绞线作为传输媒体。","link":"/2020/03/07/%E2%80%9C%E7%89%A9%E7%90%86%E5%B1%82/"},{"title":"HTTP/1.1、HTTP2和HTTP3","text":"主要内容 HTTP/1.1和HTTP/1.0对比(长连接、短连接) HTTP/1.1和HTTP/2对比 HTTP/2和HTTP/3对比 HTTP1.1与HTTP/1.0对比 HTTP/1.1默认使用持久化连接(长连接)，而HTTP/1.0使用短连接。 管线化 客户端可以同时发出多个HTTP请求，而不用一个个等待响应 断点续传 实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输。 长连接和短连接短连接就是：每请求一个资源都要重新进行一次HTTP连接。 比如我们请求一个网页，这个网页中包含html文档、js文件、css文件、图片等，对每个资源都进行一次HTTP连接。 短连接过程：建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接 长连接就是：建立一次连接，多次请求均由这个连接完成！ 只要客户端和服务器端任意一端没有明确提出断开TCP连接，就一直保持连接。 当然如果这个连接阻塞了，还是会开新的TCP连接的 长连接的过程：建立连接——数据传输…（保持连接）…数据传输——关闭连接 由于HTTP协议传输层是TCP协议，所以HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。 管线化长连接使管线化连接成为了可能，客户可以不等待响应，直接发送下一个请求，从而做到同时并行发送多个请求，节约时间。 HTTP/1.1、HTTP/2和HTTP/3的发展HTTP2和HTTP/1.1对比虽然上面提到了HTTP/1.1的很多优点，但是HTTP/1.1仍然存在着很多不足： 队头阻塞(Head of line blocking) HTTP/1.1通过管道技术实现一次性发送多个请求,但是这种技术在接收响应时，要求必须按照发送请求的顺序返回。如果，第一个请求被堵塞了，则后面的请求即使处理完毕了，也需要等待，这就是队头阻塞。 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分 发送冗长的首部。每次互相发送相同的首部造成的浪费较多 没有请求优先级控制 请求只能从客户端开始，服务器只能被动响应 针对上述问题HTTP/2对HTTP/1.1做了以下改进： 多路复用 HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。 图片来自文章HTTP2和HTTPS不来了解下 二进制格式HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式。头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧。 数据流HTTP2连接上传输的每个帧都关联到一个“流”。流是一个独立的，双向的帧序列可以通过一个HTTP2的连接在服务端与客户端之间不断的交换数据。此外，客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。 头部压缩HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的分。这就是所谓的HPACK 算法 服务器推送HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。 例如，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送 HTTP/3和HTTP/2对比HTTP/2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。 所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。 HTTP/1.1 中的管道传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了 HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。 这都是基于 TCP 传输层的问题，所以HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！ UDP 发生是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的一个丢包全部重传问题。 大家都知道 UDP 是不可靠传输的，但基于 UDP 的QUIC 协议 可以实现类似 TCP 的可靠性传输。 QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。 TL3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack。 HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。","link":"/2020/03/10/HTTP-1-1%E3%80%81HTTP2%E5%92%8CHTTP3/"},{"title":"HTTP(一)","text":"主要内容 HTTP协议概念和特点 HTTP状态码 HTTP请求方法 HTTP报文 URL和URI Cookie和Session HTTP概念和特点什么是HTTP呢？ HTTP (HyperText Transfer Protocol)是超文本传输协议，超文本指的是包含文字、图片、音频、视频的资源。 HTTP 协议是双向的。 HTTP 是一个在计算机世界里专门在两点之间传输数据的约定和规范 HTTP特点(针对http/1.1而言)： 参考文章硬核！30 张图解 HTTP 常见的面试题 优点 简单 HTTP 基本的报文格式就是header + body，头部信息也是 key-value 简单文本的形式，易于理解。 灵活和易于扩展 HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。 同时 HTTP 由于是工作在应用层（ OSI 第七层），则它下层可以随意变化。HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCPP 层换成了基于 UDP 的 QUIC。 应用广泛和跨平台从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用片地开花，同时天然具有跨平台的优越性。 缺点 HTTP 协议里有优缺点一体的双刃剑，分别是「无状态、明文传输」，同时还有一大缺点「不安全」。 无状态双刃剑 无状态的好处，因为服务器不会去记忆 HTTP 的状态，所以能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。 无状态的坏处，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。 对于无状态的问题，可以使用比较简单的方式用 Cookie技术解决。 明文传输双刃剑 明文传输的好处是在传输过程中的信息是可方便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。 明文传输的坏处在于HTTP 的所有信息毫无隐私可言，很容易就能被窃取 不安全 不安全是HTTP协议比较严重的缺点，可以使用 HTTPS 解决 HTTP状态码状态码用来描述客户端向服务器端发送请求时，服务端返回的请求结果。 1XX 1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。 2XX 一般是请求成功 200 OK 正常处理 204 No Content 成功处理，但服务器没有新数据返回，显示页面不更新 206 Partial Content 对服务器进行范围请求，只返回一部分数据 3XX 一般表示重定向 301 Moved Permanently 请求的资源已分配了新的URI中，URL地址改变了。【永久重定向】 302 Found 请求的资源临时分配了新的URI中，URL地址没变【转发】 303 See Other 与302相同的功能，但明确客户端应该采用GET方式来获取资源 304 Not Modified 发送了附带请求，但不符合条件【返回未过期的缓存数据】 307 Temporary Redirect 与302相同，但不会把POST请求变成GET 4XX 表示客户端出错了 400 Bad Request 请求报文语法错误了 401 Unauthrized 需要认证身份 403 Forbidden 没有权限访问 404 Not Found 服务器没有这个资源 5XX 服务器出错了 500 Internal Server Erro 内部资源出错了 503 Service Unavailable 服务器正忙 HTTP请求方法 我们比较常用的就是GET和POST了 GET和POST区别： GET方法时请求从服务器获取资源，而POST方法是向URI指定资源提交数据。 GET方法是安全且幂等的，而POST方法是不安全且不幂等的。 GET请求响应能被缓存，而POST请求响应不能缓存(一般也不缓存) GET请求参数以查询字符串出现在URL中，而POST请求参数存储在实体中。 对于第2点补充下安全和幂等的概念： 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。 那么很明显 GET方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。 POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。 HTTP报文HTTP报文可以分为报文首部、空行、报文主体两块。客户端的HTTP报文称为请求报文，服务器端的叫做响应报文。 对于请求报文主要包含：a、请求行：包含请求方法、URI、HTTP版本信息 (GET /HTTP/1.1)b、请求首部字段（请求头）c、空行d、请求内容实体 对于响应报文主要包含：a、响应行：包含HTTP版本、状态码、状态码的原因短语(HTTP/1.1 200 OK)b、响应首部字段（响应头）c、空行d、请求内容实体 下面是我们访问www.baidu.com的请求头和响应头。请求头： 响应头： 我们知道请求头和响应头一共包含四种首部字段，下面直接给出参数，以供以后查阅 请求首部字段 响应首部字段 通用首部字段 实体首部字段 URL和URIURI是统一资源标识符URL是统一资源定位符 对于URI和URL的理解，可以这样理解：对于网络中的所有资源，我们需要统一来对资源进行唯一标识 URI就是一种规定，说可以根据不同的协议来用不同的方式来表示资源的定位标识符。而URL和URN就是一种具体的实现。 URL就是通过网络资源的位置来唯一标识网络上的资源，URN就是通过编号来进行标识。 Cookie和SessionCookie Cookie是解决HTTP/1.1的无状态连接的 Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。 Cookie的用途 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） Cookie的创建和工作过程服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。 HTTP/1.0 200 OKContent-type: text/htmlSet-Cookie: yummy_cookie=chocoSet-Cookie: tasty_cookie=strawberry 客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。 GET /sample_page.html HTTP/1.1Host: www.example.orgCookie: yummy_cookie=choco; tasty_cookie=strawberry SessionSession 可以用来将用户信息存储在服务器端，存储在服务器端的信息更加安全。 Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。 使用 Session 维护用户登录状态的过程如下 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中； 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID； 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中； 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后拿到 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。 应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。","link":"/2020/03/10/HTTP/"},{"title":"HTTP和HTTPS","text":"主要内容 HTTPS = HTTP + SSL/TSL HTTPS之混合加密 HTTPS之数字证书 HTTPS之摘要算法 HTTPS连接建立过程 HTTP的不足以及HTTPS的改进我们之前提到HTTP协议是不安全的，主要原因在于： 窃听风险 通信使用明文（不加密），内容可能会被窃听。比如，账号信息容易泄漏。 冒充风险 不验证通信方的身份，因此有可能遭遇伪装。比如，访问假的淘宝、拼多多。 篡改风险 无法证明报文的完整性，所以有可能已遭篡改。比如，网页上植入垃圾广告。 HTTPS在HTTP和TCP层加入了SSL/TLS协议来解决上述风险。 SSL(Secure Socket Layer)指安全套接层，发展到SSL3.0之后IETF对SSL3.0进行了标准化并添加了少数机制，之后更名为TLS1.0(Transport Layer Security 安全传输层协议)。 HTTP+加密+认证+完整性保护=HTTPS HTTPS解决方式： 混合加密的方式实现信息的机密性，解决了窃听的风险。 （加密） 将服务器公钥放入到数字证书中，解决了冒充的风险。 （认证） 摘要算法的方式来实现完整性，摘要算法用于校验数据的完整性，解决了篡改的风险。（完整性保护） 混合加密算法对称密钥加密对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。优点：运算速度快；缺点：无法安全地将密钥传输给通信方。 非对称密钥加密(公开密钥加密)非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。 公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。 非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。 优点：可以更安全地将公开密钥传输给通信发送方；缺点：运算速度慢。 混合加密HTTPS结合了公开密钥安全和对称密钥运算速度快的优点，使用混合加密方式。 在通信建立前采用 非对称加密 的方式交换会话秘钥，后续就不再使用非对称加密。 在通信过程中全部使用对称加密的会话秘钥的方式加密明文数据 数字证书我们从上面知道客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。这里存在一个问题，如何保证公钥不被篡改和信任度？即无法证明公开密钥本身就是货真价实的公开密钥。 所以这里就需要借助第三方权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。 摘要算法 这部分参考文章硬核！30 张图解 HTTP 常见的面试题 摘要算法用来实现完整性，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。 客户端在发送明文之前会通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」一同加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的「指纹」和当前算出的「指纹」做比较，若「指纹」相同，说明数据是完整的。 HTTPS连接建立过程SSL/TLS 协议基本流程： 客户端向服务器索要并验证服务器的公钥。 双方协商生产「会话秘钥」。 双方采用「会话秘钥」进行加密通信。 前两步也就是 SSL/TLS 的建立过程，也就是握手阶段。 SSL/TLS 的「握手阶段」涉及四次通信，可见下图： SSL/TLS 协议建立的详细流程： ClientHello 首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。 在这一步，客户端主要向服务器发送以下信息： （1）客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。 （2）客户端生产的随机数（Client Random），后面用于生产「会话秘钥」。 （3）客户端支持的密码套件列表，如 RSA 加密算法。 SeverHello 服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容： （1）确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。 （2）服务器生产的随机数（Server Random），后面用于生产「会话秘钥」。 （3）确认的密码套件列表，如 RSA 加密算法。 （4）服务器的数字证书。 3.客户端回应 客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。 如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息： （1）一个随机数（pre-master key）。该随机数会被服务器公钥加密。 （2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。 （3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。 上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。 服务器的最后回应 服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发生最后的信息： （1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。 （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。 至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。","link":"/2020/03/10/HTTP%E5%92%8CHTTPS/"},{"title":"Java常用类","text":"","link":"/2020/03/10/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/"},{"title":"多线程开篇","text":"主要内容 程序、进程、线程、并行、并发 创建线程的三种基本方式(线程池的方式后面再加) 基本概念程序、进程、线程 程序：是为完成特定任务，用某种语言编写的一组指令的集合，即指一段静态的代码，静态对象。 进程：是程序的一次执行过程，或是正在运行的一个程序，是一个动态的过程，有它自身的产生，存在和消亡的过程。 线程：进程可进一步细化为线程，是一个程序内部的一条执行路径 进程和线程的对比： 进程是资源分配的基本单位,而线程不拥有资源（也有一点儿必不可少的资源），但同一进程内多个线程共享进程内的资源 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，则会引起进程切换。 创建或撤销进程时的开销远大于创建或撤销线程时的开销。(创建或撤销进程时，系统都要为之分配或回收资源) 线程不能单独执行，必须组成进程，一个进程至少有一个主线程。简而言之，一个程序至少有一个进程，一个进程至少有一个线程。 并行、并发 并行：一个时间点多个程序可以同时执行。(**多个人同时做多件事) 多核多CPU或多机器处理同一段处理逻辑的时候，同一时刻多个执行流共同执行 并发：一段时间内多个程序可以运行。一个CPU，通过CPU的调度算法，使用户感觉像是同时处理多个任务，但同一时刻只有一个执行流占用CPU执行。 创建线程的三种基本方式创建线程的3中基本方式： 继承 Thread类 实现 Runnable接口 实现 Callable接口 继承Thread类继承Thread类，重写run方法 12345678public class MyThread extends Thread { @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(); } }} 调用时直接使用线程的start()方法。 12345678910public class test { public static void main(String[] args) { //创建两个线程 MyThread t1 = new MyThread1(); MyThread t2 = new MyThread1(); //启动线程 t1.start(); t2.start(); }} 实现Runnable接口实现Runnable接口，实现run方法 12345678public class MyRunnable implements Runnable { @Override public void run() { for (int i = 0; i &lt;100 ; i++) { System.out.println(i); } }} 注意调用线程时，还是使用Thread的start()方法。 123456789101112public class test { public static void main(String[] args) { //创建实现Runnable接口的类对象 Runnable myRunnable = new MyRunnable(); //将接口类对象作为参数传递到Thread类创建线程 Thread t1 = new Thread(myRunnable); Thread t2 = new Thread(myRunnable); //启动线程 t1.start(); t2.start(); }} 实现Callable接口基于java.util.concurrent.Callable工具类的实现 123456public class MyCallable implements Callable { @Override public Object call() throws Exception { return 1; }} 12345678910111213141516171819public class test { public static void main(String[] args){ //创建实现Callable接口的类对象 Callable myCallable = new MyCallable(); //构建FutureTask对象 FutureTask&lt;Integer&gt; integerFutureTask = new FutureTask&lt;&gt;(myCallable); //创建线程 Thread t1 = new Thread(integerFutureTask); //启动线程 t1.start(); try { System.out.println(integerFutureTask.get()); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } }} 我们还可以使用匿名内部类的方式或者lambda表达式的方式简化上面的书写 匿名内部类 1234567891011121314151617181920212223public class test { public static void main(String[] args){ //实现Runnable接口方法 new Thread(new Runnable() { @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(i); } } }).start(); //继承Thread类方法 new Thread(){ @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(i); } } }.start(); }} 当然还可以使用Java8新特性lambda表达式的形式 123456789public class test { public static void main(String[] args){ new Thread(()-&gt;{ for (int i = 0; i &lt; 100; i++) { System.out.println(i); } }).start(); }} 注意事项实现接口 VS 继承 Thread 实现接口会更好一些，因为： Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口； 实现Runnable接口更适合用来处理多个线程共享数据的情况。 类可能只要求可执行就行，继承整个 Thread 类开销过大。 start()方法和run()方法 start()方法的作用：1.启动当前线程 2.调用当前线程的run()方法(在主线程中生成子线程，有两条线程) run()方法的作用：在主线程中调用后，只有主线程一条线程中执行了该线程方法。(调用线程run方法，只调用run方法，并不新开线程) Runnable接口和Callable接口 使用方法相似，只不过Callable接口功能更丰富些： call方法可以有泛型返回值(获取返回结果需要借助FutureTask类) call方法可以抛出异常 Runnable接口源代码 123public interface Runnable { public abstract void run();} Callable接口源代码 1234@FunctionalInterface //支持函数式接口public interface Callable&lt;V&gt; { V call() throws Exception;}","link":"/2020/03/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"title":"数据链路层","text":"主要内容 数据链路层的三个基本问题：封装成帧、透明传输、差错检测 点对点信道PPP协议 和 广播信道CSMA/CD协议 局域网、以太网、MAC地址和适配器 集线器、网桥、交换机 虚拟局域网(VLAN) 以太网网络接入PPPoE协议 链路层提供的服务1.封装成帧所有在因特网上传送的数据都是以IP数据报为传送单位的，网络层的IP数据报传送到数据链路层就成为帧的数据部分，在帧的数据部分的前面和后面添加上首部和尾部，构成一个完整的帧。 图为RFC 1042和以太网的封装格式其中CRC字段用于帧内后续字节差错的循环冗余码检验 最大传送单元(MTU)(Maximum Transfer Unit)：每一种链路层协议都规定了帧的数据部分的长度上限。比如上图中以太网数据帧的长度最大值分别是1500字节。 路径MTU:如果两台主机之间的通信要通过多个网络，那么每个网络的链路层就可能有不同的MTU。重要的不是两台主机所在网络的MTU的值，重要的是两台通信主机路径中的最小MTU。它被称作路径MTU。注意：从A到B的路由可能与从B到A的路由不同，因此路径MTU在两个方向上不一定是一致的 2.透明传输透明传输，即无论什么样的比特流都能够通过数据链路层传输。 帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。 解决这种矛盾的方法是，将数据中可能出现的控制字符的前面插入转义字符“ESC”，而在接收端再删除该转义字符，这种方法被称为字节填充。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。 3.差错检测现实的通信线路都不会是理想的，比特在传输过程中可能会产生差错：1可能会变成0，0也可能会变成1。为了保证数据传输的可靠性，必须采用各种差错检测措施。目前在数据链路层广泛使用的是循环冗余检验CRC（Cyclic Redundancy Check） 我们并没有要求数据链路层向网络层提供“可靠传输”服务，是因为：“可靠传输”指的是数据链路层发送端发送什么，在接收端就收到什么。而传输差错除了上面提到的比特差错外，还会有一些其他差错。如帧丢失、帧重复或帧失序。 信道分类点对点信道一对一通信因为不会发生碰撞，因此也比较简单，使用 PPP(Point-to-PointProtocol)协议进行控制。 PPP协议我们知道，因特网用户通常都要连接到某个ISP才能接入到因特网。PPP协议就是用户计算机和ISP进行通信时所使用的数据链路层协议。 PPP协议由三个部分组成：（1）一个将IP数据报封装到串行链路的方法。（2）一个用来建立、配置和测试数据链路连接的链路控制协议LCP（Link Control Protocol）。（3）一套网络控制协议NCP（Network Control Protocol）。 当用户拨号接入ISP后，就建立了一条从用户PC机到ISP的物理连接。这时，用户PC机向ISP发送一系列的LCP分组（封装成多个PPP帧），以便建立LCP连接。这些分组及其响应选择了将要使用的一些PPP参数。接着还要进行网络层配置，NCP给新接入的用户PC机分配一个临时的IP地址。这样，用户PC机就成为一个拥有IP地址的主机了。 当用户通信完毕时，NCP释放网络层连接，收回原来分配出去的IP地址。接着，LCP释放数据链路层连接。最后释放的是物理层的连接。 PPP帧结构 F 字段为帧的定界符 A 和 C 字段暂时没有意义 FCS 字段是使用 CRC 的检验序列 信息部分的长度不超过 1500 广播信道一对多通信 一个节点发送的数据能够被广播信道上所有的节点接收到。局域网就是一个很好的例子 由于所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。 主要有两种控制方法进行协调，一个是使用信道复用技术(代价较高，不适用于局域网)，一是使用 CSMA/CD（载波监听多点接入/碰撞检测）协议。 CSMA/CD协议CSMA/CD 表示载波监听多点接入 / 碰撞检测。 多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。 载波监听 ：不管在发送前还是在发送中，每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。 碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。 记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称2τ为争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用截断二进制指数退避算法来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取r倍的争用期作为重传等待时间。 局域网局域网主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。 局域网具有广播功能，从一个站点可很方便地访问全网，局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 局域网主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。 按照网络拓扑结构对局域网进行分类: 以太网由于以太网技术的快速发展，目前在局域网市场中占据了绝对优势，现在以太网几乎成为了局域网的同义词。 传统以太网是总线型网络结构，但随着集线器和双绞线的出现，以太网主要是星型网络拓扑结构。从表面上看，使用集线器的局域网在物理上是一个星型网，但由于集线器使用电子器件模拟实际电缆线工作，因此在逻辑上仍然是一个总线网，使用的还是CSMA/CD协议。 MAC地址MAC 地址是链路层地址，长度为 6 字节（48位），用于唯一标识网络适配器（网卡）。 一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。 MAC帧格式： 如上图所示，MAC地址由五个字段组成。前两个字段为目的地址和源地址。第三个字段是类型字段，用来标识上一层使用的是什么协议，以便把收到的MAC帧的数据上交给上一层的这个协议。第四个字段是数据字段，最后一个是帧检验序列FCS（使用CRC检验）。 适配器计算机与外界局域网的连接是通过适配器。 计算机的硬件地址就在适配器的ROM中，而计算机的IP地址则在计算机的存储器中。 适配器有帧过滤功能。适配器从网络上每收到一个MAC帧就先用硬件检查MAC帧中的目的地址，如果是发往本站的帧则收下，否则丢弃。发往本站的帧包括以下三种帧： 单播帧，即收到的帧的MAC地址与本站的硬件地址相同。 广播帧，即发送给本局域网上所有站点的帧。（全1） 多播帧，即发送给本局域网上一部分站点的帧。 局域网的扩展在物理层扩展局域网集线器 采用双绞线的以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做集线器(hub) 集线器使用电子器件模拟实际电缆线工作，因此在逻辑上仍然是一个总线网 由于是总线网结构,因此集线器使用的还是CSMA/CD协议。所以同一个时间只能有两个端口是互联的，其它的端口都处于载波侦听状态，无法使用网络带宽。 集线器工作在物理层， 作用于比特而不是帧.当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。 优点： 使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信。 扩大了局域网覆盖的地理范围。 缺点 碰撞域增大了，但总的吞吐量并未提高。 如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。 在数据链路层扩展局域网网桥 工作在数据链路层。具有过滤帧的功能,当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该帧转发到哪一个接口。 优点 过滤通信量。 扩大了物理范围。 提高了可靠性。 可互连不同物理层、不同 MAC 子层和不同速率（如10Mb/s 和 100 Mb/s 以太网）的局域网 缺点 存储转发增加了时延。 在MAC子层并没有流量控制功能。 具有不同 MAC子层的网段桥接在一起时时延更大。 网桥只适合于用户数不太多(不超过几百个)和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的广播风暴。 交换机 交换式集线器淘汰了网桥，并且由于性能远超普通集线器，淘汰了在物理层的集线器。目前以太网主要使用交换机 交换机工作在数据链路层，（又称以太网交换机、交换式集线器)。交换机实质上就是一个多接口的网桥。它不会发生碰撞，能根据 MAC 地址进行存储转发。 以太网交换机工作在全双工方式。区别于传统的使用集线器的总线以太网使用CSMA/CD协议，以半双工的方式工作，以太网交换机一般工作在全双工方式，不适用CSMA/CD协议 以太网交换机具有并行性 即能同时连通多对接口，使多对主机能同时通信。所以相互通信的主机都是独占传输媒体，无碰撞地传输数据。比如对于普通 10 Mb/s 的共享式以太网，若共有 N个用户，则每个用户占有的平均带宽只有总带宽(10 Mb/s)的 N 分之一。使用以太网交换机时，虽然在每个接口到主机的带宽还是 10 Mb/s，但由于一个用户在通信时是独占而不是和其他网络用户共享传输媒体的带宽，因此对于拥有 N 对接口的交换机的总容量为 N*10 Mb/s。这正是交换机的最大优点。 以太网交换机是即插即用的 以太网交换机内部的帧交换表（又称为地址表）是通过自学习算法自动地逐渐建立起来的。 虚拟局域网虚拟局域网（Virtual Local Area Network，VLAN）是一组逻辑上的设备和用户，通过端口分配、MAC地址分配等方式将同一局域网内的主机划分为不同的区域（VLAN），不同区域之间的主机无法直接通信（即使它们都在同一个有线局域网中），而同一区域内的主机之间可以正常通信，这就好像一个局域网一样，因此叫做虚拟局域网。 与传统局域网相比优点： 网络设备的移动、添加和修改的管理开销减少 可以控制广播活动 可以提高网络的安全性 完全隔离的两个VLAN如何通信？使用VLAN干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连VLAN交换机。该干线端口属于所有VLAN，发送到任何VLAN的帧经过干线链路转发到其他交换机。 交换机如何区别到达干线端口的帧属于哪个VLAN？IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了4字节首部VLAN标签，用于表示该帧属于哪一个虚拟局域网。 使用以太网进行网络接入以太网接入的一个重要特点是它可以提供双向的带宽通信，并且可以根据用户对带宽的需求灵活的进行带宽升级。 然而以太网帧格式标准中，在地址字段部分并没有用户名字段，也没有让用户键入密码来鉴别用户身份过程，于是人们想到将PPP协议再封装到以太网中来传输，就是1999年公布的PPPoE协议。因此，PPPoE协议是宽带上网的主机使用的链路层协议。","link":"/2020/03/07/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"title":"Java多线程之Thread类源码解析","text":"主要内容 Thread类常用API 线程的生命周期 中断interrupt Thread类常用API 最常用的两个方法 12Thread.currentThread().getName() //得到当前线程名Thread.sleep(long mills) //线程睡眠 其他的建议看一下Thread类的注释和各个方法的源码，都挺简单的，直接上结论，就不贴图了。 线程能被标记为守护线程，也可以是用户线程setDaemon(boolean on) 每个线程均分配一个name，默认为（Thread-自增数字）的组合set和get方法 每个线程都有优先级.高优先级线程优先于低优先级线程执行. 1-10，默认为5set和get方法 main所在的线程组为main，构造线程的时候没有现实的指定线程组，线程组默认和父线程一样 当线程中的run()方法代码里面又创建了一个新的线程对象时,新创建的线程优先级和父线程优先级一样. 当且仅当父线程为守护线程时,新创建的线程才会是守护线程. 当JVM启动时,通常会有唯一的一个非守护线程(这一线程用于调用指定类的main()方法) 这里提一下守护线程 Daemon 守护线程是程序运行时在后台为其他线程提供服务的线程，不属于程序中不可或缺的部分。 当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。 main() 属于非守护线程。 在线程启动之前使用 setDaemon(boolean on) 方法可以将一个线程设置为守护线程。 123456789101112public class test { public static void main(String[] args){ Runnable runnable = new MyRunnable(); Thread t1 = new Thread(runnable,\"非守护线程\"); Thread t2 = new Thread(runnable,\"守护线程\"); //设置t2为守护线程 t2.setDaemon(true); t1.start(); t2.start(); }} 线程的生命周期在Thread类源码中的State枚举中有以下六种状态，下面我们分别解释下： 12345678public enum State { NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED; } 新建(NEW) 线程刚创建, 尚未启动 可运行(RUNNABLE) 正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。 阻塞(BLOCKED) 请求获取(监视器锁)从而进入synchronized 函数或者代码块，但是其它线程已经占用了该监视器锁，所以处于阻塞状态。要结束该状态进入从而RUNABLE需要其他线程释放监视器锁。 无限期等待(WAITING) 等待其它线程显式地唤醒。进入方法 | 退出方法:-: | :-:没有设置 Timeout 参数的 Object.wait() 方法 | Object.notify() / Object.notifyAll()没有设置 Timeout 参数的 Thread.join() 方法 | 被调用的线程执行完毕LockSupport.park() 方法 | LockSupport.unpark(Thread) 这里要区分 BLOCKED 和 WATING 的区别。阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用 Object.wait() 等方法进入。 限期等待(TIMED_WAITING) 无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。 进入方法 退出方法 Thread.sleep() 方法 时间结束 设置了 Timeout 参数的 Object.wait() 方法 时间结束 / Object.notify() / Object.notifyAll() 设置了 Timeout 参数的 Thread.join() 方法 时间结束 / 被调用的线程执行完毕 LockSupport.parkNanos() 方法 LockSupport.unpark(Thread) LockSupport.parkUntil() 方法 LockSupport.unpark(Thread) 调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。 死亡(TERMINATED) 可以是线程结束任务之后自己结束，或者产生了异常而结束。 所以我们可以画出线程的转换的整个流程图: 注意：这里为了方便解释，将Runnable分成了可运行和运行中。 我们看一下上面用到的几个方法的源码 yield()方法 1public static native void yield(); 因为是native方法，无法看源码。但从注释中我们知道 给调度器一个提示，当前线程愿意让出自己的用的处理器，但是调度器也可以忽略。也就是说使用yield()方法不一定能让出处理器。 因为不一定能让出处理器，所以yield()方法很少使用 sleep()方法 sleep方法有个重载方法，可以设置纳秒数。但两个方法都是直接调用了下面的本地方法。 1public static native void sleep(long millis) throws InterruptedException; 注意：sleep方法会释放cpu的时间片，但是不会释放锁 join()方法 在线程中调用另一个线程的 join() 方法，会将当前线程挂起(底层调用的是Object的wait()方法)。 join方法一共有三个重载方法： 123456//不带时间，实际调用的是第2个方法，只不过参数设置为0public final void join() throws InterruptedException//带时间参数public final synchronized void join(long millis) throws InterruptedException//带时间参数，只不过可以设置纳秒值和2基本相同public final synchronized void join(long millis, int nanos) throws InterruptedException 所以我们看下的源代码： 12345678910111213141516171819202122232425public final synchronized void join(long millis) throws InterruptedException { long base = System.currentTimeMillis(); long now = 0; //如果等待时间&lt;0,则抛出异常 if (millis &lt; 0) { throw new IllegalArgumentException(\"timeout value is negative\"); } //如果等待时间=0,则一直等待，直到线程死亡 if (millis == 0) { while (isAlive()) { wait(0); } } else {//否则等待设定时间结束 while (isAlive()) { long delay = millis - now; if (delay &lt;= 0) { break; } wait(delay);//调用Object的wait方法,让当前线程等待 now = System.currentTimeMillis() - base; } } } demo 12345678public class A extends Thread { @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(Thread.currentThread().getName()+\"--\"+i); } }} 12345678910111213141516171819public class B extends Thread { private A a; public B(A a) { this.a = a; } @Override public void run() { for (int i = 0; i &lt; 100; i++) { try { a.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+\"--\"+i); } }} 123456789public class test { public static void main(String[] args){ A a = new A(); B b = new B(a); b.start(); a.start(); }} 上面B线程先start()，但是由于在B线程中调用了A线程的join方法，所以最后结果会是A线程先运行完后，B线程在运行完。 中断关于中断Thread类中一共有四个方法： 1234public void interrupt();public static boolean interrupted();public boolean isInterrupted();private native boolean isInterrupted(boolean ClearInterrupted); 接下来我们根据源码分析一下这几个方法。 interrupt()方法 通过调用一个线程的 interrupt() 来中断该线程，注意这里的中断不会真正停止一个线程，而仅仅是设置了一个中断标志(中断状态设为true)。 只能该线程自身调用，否则可能会抛出SecurityException异常。 如果该线程处于阻塞、限期等待或者无限期等待状态，调用interrupt()方法，中断状态会被清除(interrupt()方法会直接将其标记为true,但由于处于阻塞状态，会立即将true改为false即将中断状态清除)，并且抛出InterruptedException异常，从而提前结束该线程。 不能中断 I/O 阻塞和 synchronized 锁阻塞。 源码如下所示 123456789101112131415public void interrupt() { //检查是否有权限 if (this != Thread.currentThread()) checkAccess(); //IO阻塞 synchronized (blockerLock) { Interruptible b = blocker; if (b != null) { interrupt0(); //本地方法，设置中断标志 b.interrupt(this); return; } } interrupt0(); //本地方法，设置中断标志 } 使用中断方式终止处于阻塞、无限期等待、限期等待的状态 123456789101112public class MyRunnable implements Runnable { @Override public void run() { try { //调用sleep方法进入限期等待状态 Thread.sleep(500); System.out.println(\"Thread run\"); } catch (InterruptedException e) { e.printStackTrace(); } }} 123456789public class test { public static void main(String[] args){ Thread t1 = new Thread(new MyRunnable()); t1.start(); //调用interrupt()方法直接终止上述状态并抛出InterruptException异常 t1.interrupt(); System.out.println(\"main run\"); }} 调用interrupt()方法直接终止上述状态并抛出InterruptException异常 interrupted()方法 检测中断并清除中断状态 注意interrupted()方法作用于当前线程而不是调用interrupted方法的线程 如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。 但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。 interrupted()方法也是调用的是带有boolean参数的本地isInterrupted(boolean ClearInterrupted)方法，并且会将中断标志清除 123public static boolean interrupted() { return currentThread().isInterrupted(true); } demo 123456789public class MyRunnable implements Runnable { @Override public void run() { while(!Thread.interrupted()){ System.out.println(\"循环中\"); } System.out.println(\"跳出了循环\"); }} 不设置t1.interrupt()会一直循环，设置了之后直接跳出循环。 1234567public class test { public static void main(String[] args){ Thread t1 = new Thread(new MyRunnable()); t1.start(); //t1.interrupt(); }} isInterrupted()方法 检测中断不清除中断状态 注意interrupted()方法作用于调用此方法的实例的线程 从下面的源码中知道isInterrupted()方法调用的是带有boolean参数的本地isInterrupted(boolean ClearInterrupted)方法。并且不会改变线程中断状态 1234567//isInterrupted()public boolean isInterrupted() { return isInterrupted(false); }//isInterrupted(boolean ClearInterrupted)方法private native boolean isInterrupted(boolean ClearInterrupted); 123public static boolean interrupted() { return currentThread().isInterrupted(true); } demo 12345678910public class MyRunnable implements Runnable { @Override public void run() { //只是这里和上面不一样，结果却是一样的。 while(!Thread.currentThread().isInterrupted()){ System.out.println(\"循环中\"); } System.out.println(\"跳出了循环\"); }} 不设置t1.interrupt()会一直循环，设置了之后直接跳出循环。 1234567public class test { public static void main(String[] args){ Thread t1 = new Thread(new MyRunnable()); t1.start(); //t1.interrupt(); }} 测试这两个方法作用对象的就不写了，贴一篇文章就好了Thread类中interrupt（）、interrupted（）和isInterrupted（）方法详解","link":"/2020/03/12/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BThread%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"title":"网络层(二)","text":"主要内容 IP数据报格式 IP层分组转发算法 路由选择协议 ICMP协议、ping、traceroute 路由器的功能就是进行分组转发和路由选择，路由器是如何在知道IP地址时进行分组转发或者路由选择呢？ 为此，我们需要先了解下IP数据报的格式。 IP数据报的格式 版本 : 有 4（IPv4）和 6（IPv6）两个值； 首部长度 : 占4位，因此最大值为15。值为1表示的是1个32位字的长度，也就是4字节（即单位是4个字节，最多表示60个字节）。因为IP首部固定部分长度为20字节，因此该值最小为5。如果可选字段的长度不是4字节的整数倍，就用尾部的填充部分来填充。最常用的首部长度是20字节，这时不适用任何选项。 区分服务 : 占8位，用来获得更好的服务，一般情况下不使用。 总长度 : 包括首部长度和数据部分长度。单位为字节。因此数据报最大长度为2^16-1=65535字节。但我们知道数据链路层中规定了数据帧中的数据字段的最大长度即最大传送单元MTU（通常为1500字节）。当数据报总长度超过MTU时，就必须把过长的数据报进行分片处理。在进行分片时，数据报首部中的总长度字段指分片后的每一个分片的首部长度与该分片的数据长度的总和。 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。 标志 ： 占3位，但目前只有两位有意义。其中最低位记为MF。MF=1即表示后面还有分片的数据报，MF=0表示这是若干数据报中的最后一个。中间位记为DF，意思是不能分片，只有当DF=0时才允许分片。 片偏移 : 和标识符一起，用于发生分片的情况。表明较长的分组在分片后，某片在原分组中的相对位置，也就是说相对于用户数据字段的起点。片偏移的单位为8字节。 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL为0时就丢弃数据报。 协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。 首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。 源地址：32位 目的地址：32位 分片： 分组转发算法使用分类IP的分组转发算使用分类的IP地址的转发，可以看到路由表中主要是以下两个信息： （目的网络地址， 下一跳地址） 以路由器R2的路由表为例，由于R2同时连接在网络2和3上，因此只要目的主机在网络2或3上，都可以通过接口0或1有路由器R2直接进行交付（当然还要利用地址解析协议ARP才能找到这些主机的硬件地址）。若目的主机在网络1中，则下一跳路由应为R1，其IP地址为20.0.0.7。路由器R1和R2由于同时连接在网络2上，因此从路由器R2把分组转发给路由器R1是很容易的。 使用分类IP的分组转发算法过程 从数据报的首部提取目的主机的 IP 地址 D, 得出目的网络地址为 N。 若网络 N 与此路由器直接相连，则把数据报直接交付目的主机 D；否则是间接交付，执行步骤3。 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行步骤4。 若路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行步骤5。 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行步骤6。 报告转发分组出错。 上面步骤5中提到的默认路由对于连接在小网络上的主机发送IP数据报时是十分有用的。如下图中连接在网络N1上的任何一个主机中的路由表只需要三个项目即可。 本网络主机路由，其目的网络就是本网络N1,因而不需要路由转发。 到网络N2的路由，对应的下一条路由器是R2 默认路由，只要目的网络是其他网络(不是N1或N2),就一律选择默认路由，把数据报先交付路由器R1,让R1再转发给互联网中的下一个路由，一直转发到目的网络上的路由器，最后进行直接交付。 使用子网的分组转发算法在划分子网的情况下，分组转发算法必须做相应改动，路由表中必须包含以下三项内容:目的网络地址、子网掩码、下一跳地址 使用子网的分组转发算法 从收到的数据报的首部提取目的IP地址D。 先判断是否为直接交付。对路由器直接相连的网络逐个进行检查：用各网络的子网掩码和D逐位“与”，看结果是否和相应的网络地址匹配，若匹配，则把分组进行直接交付（当然还需要把D转换成物理地址，把数据报封装成帧发送出去），转发任务结束。否则是间接交付，执行步骤3。 若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由。否则执行步骤4 对路由表中的每一行（目的网络地址、子网掩码、下一跳地址），用其中的子网掩码和D逐位相“与”，其结果为N。若N与该行的目的网络地址匹配，则把数据报传动给该行指明的下一跳路由。否则执行步骤5. 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行步骤6。 报告转发分组出错。 比如对于上面的图中H1与主机H2之间进行通信，首先H1会将H2的IP地址128.30.33.128和本子网的网络地址128.30.33.0相与，得到128.30.33.0，与自己本子网的网络地址不同，则判断为间接交付，将数据报交付给路由器R1，由R1进行转发。 路由器收到数据报后，根据路由表中的记录，将IP地址与子网掩码进行逐位相与，如先看R1路由表的第一行。将子网掩码和目的IP逐位相与后得到128.30.33.128，与这一行的目的网路地址128.30.33.0比较不匹配。 则继续寻找下一行。 可以看到在第二行中匹配成功，则不再继续找下去而是R1把分组从接口1直接交付主机H2。 使用CIDR的分组转发算法在使用CIDR时，由于采用了网络前缀的这种方法，因此在路由表中的项目也要有相应改变。这时，每个项目由两个内容构成：网络前缀、下一跳地址 但是在查找时可能会得到不止一个匹配结果，此时应当采用最长前缀匹配来确定应该匹配哪一个。这是因为网络前缀越长，其地址块越小，因而路由选择就越具体。 具体转发流程和使用子网的分组转发方法类似，只不过中间是用掩码相与后，再使用最长前缀匹配进行选择，不在赘述。 比如，大学下属四系希望ISP把转发给四系的数据报直接发送到四系而不经过大学路由器，则在ISP路由器的路由表中至少有以下两个项目，即206.0.68.0/22(大学) 和206.0.71.128/25。假定目的IP地址为D=206.0.171.130,则按照下图进行掩码逐位与后都匹配，根据最长匹配前缀原理，应当选择后者。 注意： CIDR使用32位的地址掩码，其中1的长度为网络前缀的长度，例如/20的地址掩码为11111111 11111111 11110000 0000。 虽然CIDR不使用子网了，但是仍然可将地址掩码称为子网掩码。注意这个不使用子网的意思是说没有在32位地址中指明若干位作为子网字段，但分配到一个CIDR地址块后，仍然可以在本单位继续划分子网。 并且这些子网的网络前缀比整个单位网路的网络前缀长。 由于CIDR使用的是地址块，因此在路由表中可以直接利用CIDR地址块来查找目的网络，使得路由表中的一个项目可以表示原来传统分类地址的多个路由。这种路由聚合也称为构成超网 路由选择协议路由选择协议就是用来解决路由器中的路由表是如何获得的。 互联网采用的路由选择协议主要是自适应的(即动态的)，分布式路由选择协议。 互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。在目前的互联网中，一个大的ISP就是一个自治系统。这样互联网就把路由选择协议划分为两大类： -内部网关协议IGP ： 即在一个自治系统内部使用的路由选择协议。主要有RIP 和 OSPF协议-外部网关协议EGP： 若源主机和目的主机处在不同的自治系统中，当数据报传送到一个自治系统边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议。主要有BGP协议。 内部网关协议 内部网关协议RIP RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。 RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。 距离向量算法： 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1； 对修改后的 RIP 报文中的每一个项目，进行以下步骤： 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中； 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。 RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。 内部网关协议 OSPF 开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。 开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。 OSPF 具有以下特点： 向本自治系统中的所有路由器发送信息，这种方法是洪泛法。 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。 只有当链路状态发生变化时，路由器才会发送信息。 所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。 外部网关协议 BGPBGP（Border Gateway Protocol，边界网关协议） AS 之间的路由选择很困难，主要是由于： 互联网规模很大； 各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量； AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。 BGP 只能寻找一条比较好的路由，而不是最佳路由。 每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。 网际控制报文协议ICMPICMP协议是为了能够更有效地转发IP数据报和提高交付成功的机会。但ICMP不是高层协议(虽然ICMP数据报文作为IP层数据)，而是IP层协议。 ICMP报文： ICMP报文种类有两种： ICMP差错报告报文 ICMP询问报文 常见ICMP报文类型 ICMP差错报告报文具有相同的格式： 其中取需要进行差错报告的IP数据报数据字段前8个字节是为了得到运输层端口号(对于TCP和UDP)以及运输层报文的发送序号(对于TCP)。 ICMP常见的应用就是ping和traceroute ping ping是分组网间嗅探，用来测试两台主机的连通性。 ping是应用层直接使用网络层，没有经过传输层的TCP或UDP ping百度的抓包分析： 可以看到执行ping命令后，直接进行了4次request和reply。在下面的请求报文中可以看到和上面的ICMP报文格式一一对应。这里的 Type=8,code=0, 校验是正确，且这是一个Echo请求报文。我们再点击Responseframe:8，这里说明响应报文在序号8。详情如下： 同样的Type=8,code=0校验正确，且最下面根据请求和响应的时间戳计算出来的响应延迟。 tracerouteTraceroute是ICMP的另一个应用，用来跟踪一个分组从源点到终点的路径。traceroute是UNIX系统中的名字，在windows系统中是tracert。 traceroute发送的IP数据报封装的是无法交付的UDP用户数据报（使用了非法端口号），并由目的主机发送终点不可达差错报告报文。 源主机向目的主机发送一连串的IP数据报。第一个数据报P1的生存时间TTL设置为1，当P1到达路径上的第一个路由器R1时，R1收下它并把TTL减 1，此时TTL等于0，R1就把P1丢弃，并向源主机发送一个ICMP时间超过差错报告报文； 源主机接着发送第二个数据报P2，并把TTL设置为2。P2先到达 R1，R1收下后把TTL减 1 再转发给R2，R2收下后也把TTL减1，由于此时TTL等于0，R2就丢弃P2，并向源主机发送一个ICMP时间超过差错报文。 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把TTL值减1。但是因为数据报封装的是无法交付的UDP，因此目的主机要向源主机发送ICMP终点不可达差错报告报文。 之后源主机知道了到达目的主机所经过的路由器IP地址以及到达每个路由器的往返时间。 UDP抓包(traceroute和tracert的不同)","link":"/2020/03/09/%E7%BD%91%E7%BB%9C%E5%B1%822/"},{"title":"传输层","text":"主要内容 传输层概念、端口号、套接字 UDP传输特点和数据报格式 TCP传输特点和数据报格式 可靠传输原理 TCP可靠运输的实现 TCP流量控制、拥塞控制 三次握手和四次握手抓包分析 传输层运输层向它上面应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最底层。 两个主机进行通信实际上就是两个主机中的应用进程互相通信。应用进程之间的通信又称为端到端的通信。 传输层有两种不同的协议：用户数据报协议UDP和传输控制协议TCP 学习这两个重要协议之前，先简单了解下端口的概念。 端口端口(16位)用来对 TCP/IP 体系的应用进程进行区分。 端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。在因特网中不同计算机的相同端口号是没有联系的。 端口号分为两类： 服务端使用的端口号服务器端使用的端口又分为两类：熟知端口和登记端口。熟知端口数值一般为0~1023(比如我们常见的http使用的就是80端口)。登记端口数值为1024 ~ 49151，这些端口是为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。 服务器端常见端口号： 客户端使用的端口号数值为49152~65535，留给客户进程选择暂时使用，仅在客户进程运行时才动态选择，因此又叫短暂端口号。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。 套接字套接字针对的是TCP连接，每一条TCP连接有两个端点，那两个端点称为套接字（socket） 端口号拼接到IP地址后面构成套接字。套接字socket=（IP地址：端口号） 所以每一条TCP连接唯一地被通信两端的两个端点（两个套接字）所确定。即：TCP连接::={socket1,socket2}={(IP1:port1),(IP2:port2)} 用户数据报协议UDPUDP 只在IP的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。 UDP特点 无连接 (即发送数据之前不需要建立连接) 不可靠 (UDP使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制) 面向报文 (对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部) 支持一对一、一对多、多对一、多对多的交互通信 UDP没有拥塞机制(网络出现拥塞不会使源主机发送速率降低，对于一些实时应用如视频会议等十分合适) UDP首部开销小 只有8个字节，比TCP20个字节要短。 UDP首部 首部字段只有 8 个字节，包括：源端口 源端口号，在需要对方回信时调用目的端口 目的端口号 在重点交付报文时使用长度：UDP用户数据报的长度，其最小值是8（仅有首部）检验和 检测UDP用户数据报在传输中是否有错，有错就丢弃。 注意： 虽然在UDP之间的通信要用到其端口号，但由于UDP通信是无连接的，因此不需要使用套接字。 在计算检验和时，要在UDP用户数据报之前添加12个字节的“伪首部”。这个伪首部既不向下传递也不向上递交。仅仅是为了计算检验和。 UDP在计算检验和时是把首部和数据部分一起检验，而IP数据报首部检验和只检验IP数据报首部，不检验数据部分 传输控制协议TCPTCP除了基本的数据交付和差错检查外，还提供了可靠数据传输和拥塞控制服务 TCP特点 面向连接 (应用程序使用TCP协议前必须先建立TCP连接) 只能是点对点的（一对一） (每一条TCP连接只能有两个端点) 提供可靠交付 (TCP连接传送的数据无差错、不丢失、不重复，按序到达) 全双工通信 允许通信双方的应用进程再任何时候都能发送数据。 面向字节流 （把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块） TCP首部 源端口和目的端口：各占2个字节，分别写入源端口号和目的端口号。 序号 ：占4个字节。序号范围是[0,2^32 - 1],用于对字节流进行编号。例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：占4个字节，是期望收到对方下一个报文段的第一个数据字节的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。若确认号=N，则表明：到序号N-1为止的所有数据都已正确收到 数据偏移 ：占4位，指的是TCP报文段数据起始处距离报文段起始处的偏移量，实际上指的是TCP报文段的首部长度。 保留：占6位，保留为今后使用，但目前应置为0. 紧急URG:当URG=1时，表明紧急指针字段有效。告诉系统此报文段中有紧急数据，应尽快传送，而不要按原来的排队顺序来传送。 确认 ACK ：仅当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 推送PSH：发送方把PSH置1，并立即创建一个报文段发送出去，接收方TCP收到PSH=1的报文段，就尽快地交付接收应用进程，而不用等到整个缓存都填满了后再向上交付。很少使用 复位RST：当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立运输连接。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：占2个字节。值是[0,2^16 - 1]之间的整数。窗口指的是发送本报文段一方的接收窗口。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化。 检验和：占2个字节。检验和字段检验的范围包括首部和数据这两部分。和UDP一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。 紧急指针：占2个字节。紧急指针仅在URG=1时才有意义，它指出本报文段中的紧急数据的字节数。 选项： 长度可变，最长可达40字节。当没有使用选项是，TCP首部为20字节。 可靠传输原理理想的传输条件有以下两个特点： 传输信道不产生差错。 不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。然而实际的网络都不具备以上两个理想条件。必须使用一些可靠传输协议，在不可靠的传输信道实现可靠传输 那么在TCP中就有两种方式来实现可靠传输了 停止等待协议 连续 ARQ 协议 停止等待协议“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。 停止等待协议有两种情况： 无差错情况如下图a，A发送分组M1，发送完就暂停，等待B的确认。B收到了M1就向A发送确认。A收到了对M1的确认后就再发送下一个分组M2。之后收到确认后再发送M3 出现差错可能M1在传输过程中直接丢失，B未收到分组则什么也不做或者B收到分组后检测出了差错，就丢弃M1并且也什么都不做。 对于上面分组丢失的问题，可靠传输协议的解决： A 为每一个已发送的分组都设置了一个超时计时器。 A 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 M2 。 注意： 在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发。 分组和确认分组都必须进行编号。 超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。 像上述的这种可靠传输协议常称为自动重传请求 ARQ (Automatic Repeat reQuest)。即重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组。 为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。 流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送。 连续ARQ协议滑动窗口协议是TCP协议的精髓，现在简单介绍下 发送方维持的发送窗口，它的意义是：位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。 连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。 即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。 优点：容易实现，即使确认丢失也不必重传。缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。 如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。这就叫做 Go-back-N（回退 N），表示需要再退回来重传已发送过的 N 个分组。 TCP可靠传输的实现上面我们已经了解了可靠传输的简单原理，现在我们看先TCP是如何具体实现的。 TCP 连接的每一端都必须设有一个发送窗口和一个接收窗口。两端的四个窗口经常处于动态变化之中。 TCP 的可靠传输机制用字节为单位使用字节序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。 TCP超时重传的时间选择不是固定不变的，而是自适应的（使用特定的算法估算较为合理的重传时间）。 TCP的流量控制 TCP流量控制通过滑动窗口实现，就是让发送方的发送速率不要太快，要让接收方来得及接收。 发送方的发送窗口不能超过接收方给出的接收窗口的数值。 如果B向A发送了零窗口的报文段后不久，B的接收缓存又有了一些存储空间，B向A发送非零窗口报文段，但是这个报文段丢失了，那么就会造成A一直等待收到B发送的非零窗口的通知，而B也一直等待A发送的数据，如果没有其他措施，这种互相等待的死锁局面会一直延续下去。 为了解决上述问题，TCP为每个连接接设有一个持续计时器，只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。 若持续计时器设置的时间到期，就发送一个零窗口探测报文段。对方在确认这个探测报文段时给出现在窗口值，如果窗口仍然是零，那么收到这个报文段的一方就重新设置持续计时器。如果窗口不是零就，就可以打破死锁的僵局。 TCP的拥塞控制拥塞控制原理出现拥塞的条件：对资源需求 &gt; 可用资源 即使增大资源也不是能解决拥塞的问题的。不但不能解决拥塞问题，而且还可能使网络的性能更坏。 拥塞引起的重传并不会缓解网络的拥塞，反而会加剧网络的拥塞。因为会引起更多的分组流入网络和被网络中的路由器丢弃。 拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载 拥塞控制和流量控制的区别 拥塞控制是全局性的，而流量控制是指点对点通信量的控制 拥塞控制是防止过多的数据注入到网路中，而流量控制是控制发送端发送数据的速率，以便接收端来得及接收。 拥塞控制的作用：注意横坐标代表的是单位时间内输入给网络的分组数目。 TCP拥塞控制方法有四种：慢开始、拥塞避免、快重传、快恢复。 拥塞的判断： 重传定时器超时 收到三个相同（重复）的 ACK（丢失个别报文段时，快重传对接收到的报文段的重复确认） 拥塞控制流程图：其中ssthresh为慢开始门限 TCP连接管理TCP连接建立(3次握手) 客户端A向服务器端B发出连接请求报文段，这时首部中的同步位SYN=1，同时选择一个初始序号seq=x。TCP规定，SYN报文段不能携带数据，但要消耗掉一个序号。这时，TCP客户进程进入SYN-SENT（同步已发送）状态。 B收到连接请求报文段后，如同意建立连接，则向A发送确认。在确认报文段中应把SYN位和确认ACK为都置1，确认号是ack=x+1，同时也为自己选择一个初始序号seq=y。这个报文段也不能携带数据，但同样要消耗一个序号。这时TCP服务器进程进入SYN-RCVD（同步收到）状态。 TCP客户进程收到B的确认后，还要向B给出确认。确认报文段的ACK置1.确认号ack=y+1，而自己的序号seq=x+1。TCP的标准规定，ACK报文段可以携带数据，但如果不携带数据则不消耗序号。这时，TCP连接已建立，A进入ESTABLISHEN（已建立连接）状态。 三次握手的理解第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常所以三次握手就能确认双发收发功能都正常，缺一不可。 理解清楚了之后,我们就知道为什么不能连接建立不能两次或者四次了 两次：如果没有第三次握手，服务器端无法知道自己发送和对方接收是否正常。例如，如果A发出的第一个连接请求报文没有丢失而是滞留在网络结点上，之后A再次发出请求与B建立连接，传送完数据后释放连接。这时A第一次发送的请求（失效报文）才到达B，B会误认为是A的又一个请求报文，就向A发送确认报文，同意建立连接。这时如果没有第三次握手，只要B发出确认，新的连接就直接建立，但是A没有发送建立连接请求，就会造成B一直等待A发送数据，造成B的资源浪费。 四次：没有必要，因为三次握手已经能够确保双方的收发功能正常。 抓包验证下吧第一次握手 第二次握手 第三次握手 TCP连接释放(4次挥手) 数据传输结束后，A和B处于ESTABLISHEN状态。A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A把连接释放报文段首部的FIN置1，其序号seq=u，等于前面已经传送过的数据的最后一个字节的加1.这时A进入FIN-WAIT-1（终止等待1）状态，等待B的确认。 B收到连接释放报文段后即发出确认，确认号是ack=u+1，而这个报文段自己的序号是v。等于B前面已经传送过的数据的最后一个字节的序号加1。然后B进入CLOSE-WAIT（关闭等待）状态。TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于半关闭状态。即A已经没有数据要发送了，但B若发送数据，A仍要接受。A收到来自B的确认后，就进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。 若B已经没有要向A发送的数据，其应用进程就通知TCP释放链接。这时B发出的报文段必须使FIN=1。现假定B的序号为w（在半关闭状态B可能由发送了一些数据）。B还必须重复上次已经发送过的确认号ack=u+1。这时B就进入LAST-ACK（最后确认）状态，等待A的确认。 A在收到B的连接释放报文段后，必须对此发出确认。在确认报文段中把ACK置1，确认号ack=w+1，而自己的序号是seq=u+1。然后进入到TIME-WAIT（时间等待）状态。请注意，现在TCP连接还没有释放掉。必须经过时间等待计时器设置的时间2MSL（最长报文段寿命）后，A才进入到CLOSED状态。时间MSL叫做最长报文段寿命（Maximum Segment Lifetime）。 这里抓包就不仔细分析了 A 必须等待 2MSL 的时间： 为了保证 A 发送的最后一个 ACK 报文段能够到达 B。（因为A最后发送的ACK报文段有可能丢失，因而B收不到A发送的FIN+ACK报文段的确认。B会超时重传FIN+ACK报文段，而A就能在2MSL内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器。最后正常释放连接。如果A不等待2MSL而是在发送完ACK确认报文后立即释放连接，就无法收到B重传的FIN+ACK报文，因而也就不会发送确认报文，这样B就无法进入CLOSED状态） 防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。 此外，TCP还设有一个保活计时器。服务器每收到一次客户数据，就重新设置保活计时器(时间通常为2小时)。若两小时没有收到客户的数据，则服务器发送一个探测报文段，以后每隔75s发送一次。若一连发送10个探测报文段后仍无客户的响应，服务器就认为客户端出现了故障，接着就关闭这个连接。","link":"/2020/03/09/%E4%BC%A0%E8%BE%93%E5%B1%82/"},{"title":"应用层","text":"主要内容 域名系统DNS 文件传送协议 FTP 电子邮件协议SMTP、POP3、IMAP DHCP协议 最重要的http协议单独写一篇博文啦 使用TCP和UDP的各种常见应用层协议 域名系统DNSDNS 是一个通过分层服务器实现的分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留与它相关的那部分数据。 DNS可以使用UDP或者TCP进行传输，使用的端口号都为 53。大多数情况下DNS使用UDP进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。 在两种情况下会使用TCP进行传输： 如果返回的响应超过的 512 字节（UDP 最大只支持512字节的数据）。 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。 DNS工作流程：本地域名服务器采用递归查询 文件传送协议 FTP文件传送协议 FTP (File Transfer Protocol) 是互联网上使用得最广泛的文件传送协议。 FTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限 文件传输过程 打开熟知端口（端口号为 21），使客户进程能够连接上。 等待客户进程发出连接请求。 启动从属进程来处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。 回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发地进行。 当客户进程向服务器进程发出建立连接请求时，要寻找连接服务器进程的熟知端口 (21)，同时还要告诉服务器进程自己的另一个端口号码，用于建立数据传送连接。 服务器进程用自己传送数据的熟知端口 (20) 与客户进程所提供的端口号码建立数据传送连接。 由于 FTP 使用了两个不同的端口号，所以数据连接与控制连接不会发生混乱。 FTP是使用了两个TCP连接的。好处： 使协议更加简单和更容易实现。 在传输文件时还可以利用控制连接（例如，客户发送请求终止传输）。 电子邮件协议SMTP、POP3、IMAP 注意： 不要将邮件读取协议 POP 或 IMAP 与邮件传送协议 SMTP 弄混。 发信人的用户代理向源邮件服务器发送邮件，以及源邮件服务器向目的邮件服务器发送邮件，都是使用 SMTP 协议。 而 POP 协议或 IMAP 协议则是用户从目的邮件服务器上读取邮件所使用的协议。 DHCP协议为了将软件协议做成通用的和便于移植，协议软件的编写者把协议软件参数化。在软件协议运行之前，必须给每一个参数赋值。在协议软件中给这些参数赋值的动作叫做协议配置。 互联网广泛使用的动态主机配置协议 DHCP (Dynamic Host Configuration Protocol) 提供了即插即用连网(plug-and-play networking) 的机制。 并不是每个网络上都有 DHCP 服务器，这样会使 DHCP 服务器的数量太多。现在是每一个网络至少有一个 DHCP 中继代理，它配置了 DHCP 服务器的 IP 地址信息。 注意： DHCP报文仅为UDP数据报的数据部分 DHCP 服务器分配给 DHCP 客户的 IP 地址的临时的，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的IP 地址。","link":"/2020/03/10/%E5%BA%94%E7%94%A8%E5%B1%82/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"HTTPS","slug":"HTTPS","link":"/tags/HTTPS/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"并发","slug":"并发","link":"/tags/%E5%B9%B6%E5%8F%91/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"计算机网络","slug":"计算机基础/计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Java基础","slug":"Java基础","link":"/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"多线程","slug":"Java基础/多线程","link":"/categories/Java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]}